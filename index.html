<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spanish Flashcards ‚Äì Mastery Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <meta name="theme-color" content="#0f172a" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Spanish Cards" />

  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
  />

  <style>
    :root {
      --bg-gradient: radial-gradient(circle at top left, #1e293b, #0f172a 60%, #020617);
      --card-bg: rgba(30, 41, 59, 0.7);
      --card-border: 1px solid rgba(148, 163, 184, 0.15);
      --accent: #22c55e;
      --accent-hover: #16a34a;
      --accent-soft: rgba(34, 197, 94, 0.15);
      --gold: #eab308;
      --gold-soft: rgba(234, 179, 8, 0.15);
      --text-main: #f1f5f9;
      --text-muted: #94a3b8;
      --danger: #ef4444;
      --danger-soft: rgba(239, 68, 68, 0.15);
      --radius-lg: 24px;
      --radius-md: 16px;
      --radius-sm: 12px;
      --shadow-soft: 0 10px 40px -10px rgba(0, 0, 0, 0.5);
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
      margin: 0;
      font-family: "Inter", system-ui, sans-serif;
      background: var(--bg-gradient);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 10px;
    }

    /* --- Loading Screen --- */
    #loadingScreen {
      position: fixed;
      inset: 0; z-index: 9999;
      background: #0f172a;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      transition: opacity 0.5s ease;
    }
    .loader-content { width: 80%; max-width: 400px; text-align: center; }
    .loading-bar-bg {
      width: 100%; height: 6px; background: rgba(148,163,184,0.2);
      border-radius: 99px; overflow: hidden; margin-bottom: 20px;
    }
    .loading-bar-fill {
      height: 100%; width: 30%;
      background: var(--accent);
      border-radius: 99px;
      animation: loadAnim 2s infinite ease-in-out;
    }
    @keyframes loadAnim { 0% { transform: translateX(-100%); } 100% { transform: translateX(300%); } }
    
    .fun-fact-container { min-height: 80px; display: flex; align-items: center; justify-content: center; }
    .fun-fact-text { font-size: 16px; color: #bae6fd; font-weight: 500; line-height: 1.5; opacity: 1; transition: opacity 0.5s ease; }
    .fun-fact-label { font-size: 11px; text-transform: uppercase; color: var(--text-muted); letter-spacing: 1px; margin-bottom: 8px; }

    /* --- App Container --- */
    .app {
      width: 100%;
      max-width: 800px;
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: var(--card-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-soft);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 85vh;
    }

    /* --- Header --- */
    .app-header {
      padding: 16px;
      border-bottom: var(--card-border);
      background: rgba(15, 23, 42, 0.8);
    }

    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      gap: 10px;
    }

    .logo-block h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
      letter-spacing: -0.02em;
    }

    .logo-pill {
      font-size: 9px;
      text-transform: uppercase;
      background: var(--accent-soft);
      border-radius: 99px;
      padding: 2px 6px;
      color: #86efac;
      letter-spacing: 0.05em;
      border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .header-actions {
        display: flex;
        gap: 12px;
        align-items: center;
    }

    .btn-settings {
        background: transparent; border: none; font-size: 20px; cursor: pointer; padding: 0;
        transition: transform 0.2s;
    }
    .btn-settings:hover { transform: rotate(45deg); }

    .deck-description {
      margin: 4px 0 0 0; font-size: 13px; color: var(--text-muted); line-height: 1.4;
    }

    /* Stats Pills */
    .stats-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .stat-pill {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 99px;
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-muted);
      display: inline-flex;
      gap: 4px;
      cursor: pointer;
      transition: 0.2s;
    }
    .stat-pill:hover { background: rgba(30, 41, 59, 0.9); border-color: var(--text-muted); }
    .stat-pill strong { color: var(--text-main); font-weight: 600; }
    
    .stat-pill.accent { border-color: rgba(34, 197, 94, 0.4); color: #bbf7d0; background: rgba(34, 197, 94, 0.1); }
    .stat-pill.danger { border-color: rgba(239, 68, 68, 0.4); color: #fecaca; background: rgba(239, 68, 68, 0.1); }
    .stat-pill.gold { border-color: rgba(234, 179, 8, 0.4); color: #fde047; background: rgba(234, 179, 8, 0.1); }

    /* --- Navigation Tabs --- */
    .nav-tabs {
      display: flex;
      gap: 6px;
      background: rgba(15, 23, 42, 0.6);
      padding: 4px;
      border-radius: 99px;
      border: var(--card-border);
      overflow-x: auto;
    }

    .nav-tab {
      flex: 1;
      border: none;
      background: transparent;
      color: var(--text-muted);
      padding: 8px 12px;
      border-radius: 99px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      white-space: nowrap;
    }
    .nav-tab:hover { color: var(--text-main); background: rgba(255,255,255,0.03); }
    .nav-tab.active {
      background: var(--accent);
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 2px 10px rgba(34, 197, 94, 0.3);
    }

    /* --- Panels --- */
    .panel-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow-y: auto;
    }
    .panel { display: none; padding: 20px; animation: fadeIn 0.2s ease; }
    .panel.active { display: block; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

    /* --- Deck Grid --- */
    .deck-grid { 
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px; 
      margin-bottom: 20px;
    }
    
    .deck-card {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.1);
      border-radius: var(--radius-sm);
      padding: 16px 12px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      gap: 8px;
      position: relative;
      min-height: 100px;
      word-break: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
    }

    .deck-card:hover { background: rgba(30, 41, 59, 0.9); border-color: rgba(148, 163, 184, 0.3); transform: translateY(-2px); }
    .deck-card.active { border-color: var(--accent); background: rgba(34, 197, 94, 0.05); }
    
    .deck-card.mastered-green {
      border-color: var(--accent);
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.6), rgba(34, 197, 94, 0.1));
    }
    .deck-card.mastered-green::after {
      content: '‚úî'; position: absolute; top: 6px; right: 6px;
      color: var(--accent); font-size: 12px;
    }

    .deck-card.mastered-gold {
      border-color: var(--gold);
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.6), rgba(234, 179, 8, 0.15));
      box-shadow: 0 0 15px rgba(234, 179, 8, 0.1);
    }
    .deck-card.mastered-gold::after {
      content: '‚òÖ'; position: absolute; top: 6px; right: 6px;
      color: var(--gold); font-size: 14px;
    }

    /* Red Struggle Card Style */
    .deck-card.mastered-red {
        border-color: var(--danger);
        background: linear-gradient(135deg, rgba(30, 41, 59, 0.6), rgba(239, 68, 68, 0.15));
    }
    .deck-card.mastered-red::after {
        content: '‚ö†'; position: absolute; top: 6px; right: 6px;
        color: var(--danger); font-size: 12px;
    }

    .deck-card.diff-card {
        flex-direction: row;
        align-items: center; 
        text-align: left;
        gap: 12px; 
        padding: 12px 16px;
        justify-content: flex-start;
    }
    .diff-emoji { 
        font-size: 24px; 
        line-height: 1; 
        min-width: 28px;
        text-align: center;
    }
    .diff-text-col { display: flex; flex-direction: column; gap: 2px; flex: 1; min-width: 0; }
    .diff-title { font-weight: 700; font-size: 15px; color: var(--text-main); }
    .diff-sub { font-size: 11px; color: var(--text-muted); }

    .deck-icon { font-size: 22px; margin-bottom: 2px; }
    .deck-title { font-weight: 600; font-size: 13px; line-height: 1.3; }
    .deck-count { font-size: 10px; color: var(--text-muted); }
    .deck-section-title { margin: 0 0 15px 0; font-size: 18px; font-weight: 600; color: #fff; }

    /* New Deck Features */
    .deck-progress-track {
        width: 100%; height: 4px; background: rgba(148,163,184,0.2);
        border-radius: 99px; margin: 4px 0; overflow: hidden;
    }
    .deck-progress-fill {
        height: 100%; background: var(--accent); width: 0%;
        transition: width 0.3s ease;
    }
    .dir-indicators {
        display: flex; gap: 4px; justify-content: center; margin-top: 2px;
    }
    .dir-box {
        font-size: 8px; background: rgba(15,23,42,0.4); border: 1px solid rgba(148,163,184,0.2);
        color: var(--text-muted); padding: 1px 4px; border-radius: 4px;
        text-transform: uppercase; font-weight: 600;
    }
    .dir-box.completed {
        background: rgba(34,197,94,0.2); border-color: rgba(34,197,94,0.4); color: #86efac;
    }

    /* --- Stats Dashboard --- */
    .stats-dashboard {
      background: linear-gradient(to right, rgba(30, 41, 59, 0.5), rgba(15, 23, 42, 0.5));
      border: 1px solid rgba(148, 163, 184, 0.1);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin-bottom: 24px;
      margin-top: 10px;
    }
    .sd-title { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 12px; }
    .sd-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .sd-item { display: flex; flex-direction: column; gap: 4px; }
    .sd-item.span-2 { grid-row: span 2; justify-content: center; cursor: pointer; transition: transform 0.2s; } 
    .sd-item.span-2:hover { transform: scale(1.02); }
    .sd-val { font-size: 18px; font-weight: 700; color: var(--text-main); }
    .sd-label { font-size: 11px; color: var(--text-muted); }
    .rank-bar { height: 4px; background: rgba(255,255,255,0.1); border-radius: 99px; margin-top: 8px; overflow: hidden; }
    .rank-fill { height: 100%; background: var(--gold); border-radius: 99px; width: 0%; transition: width 1s ease; }

    /* Rank List Page */
    .rank-list { display: flex; flex-direction: column; gap: 12px; margin-top: 10px; }
    .rank-card-item {
        background: rgba(30, 41, 59, 0.4);
        border: 1px solid rgba(148, 163, 184, 0.1);
        border-radius: var(--radius-sm);
        padding: 16px;
        display: flex; align-items: center; gap: 15px;
    }
    .rank-card-item.completed { opacity: 0.7; }
    .rank-card-item.locked { opacity: 0.4; filter: grayscale(1); }
    .rank-card-item.current {
        background: rgba(234, 179, 8, 0.1);
        border-color: rgba(234, 179, 8, 0.3);
        box-shadow: 0 0 15px rgba(234, 179, 8, 0.1);
    }
    .rank-icon-large { font-size: 28px; width: 40px; text-align: center; }
    .rank-info-col { flex: 1; }
    .rank-name-title { font-weight: 700; font-size: 15px; color: var(--text-main); }
    .rank-desc { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
    .rank-progress-wrap { height: 4px; background: rgba(0,0,0,0.3); border-radius: 99px; margin-top: 8px; overflow: hidden; }
    .rank-progress-bar { height: 100%; background: var(--gold); width: 0%; }

    /* Notification Banner */
    .notification-banner {
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(150px);
        background: linear-gradient(135deg, #ca8a04, #854d0e);
        color: white; padding: 16px 24px; border-radius: 99px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        display: flex; align-items: center; gap: 12px; z-index: 2000;
        transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.27);
        pointer-events: none; opacity: 0; min-width: 280px; justify-content: center;
    }
    .notification-banner.show { transform: translateX(-50%) translateY(0); opacity: 1; pointer-events: auto; }
    .notif-icon { font-size: 20px; }
    .notif-text { font-weight: 600; font-size: 14px; }

    /* Breadcrumbs */
    .breadcrumbs { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; }
    .back-btn {
      background: transparent; border: 1px solid rgba(148, 163, 184, 0.3);
      color: var(--text-muted); padding: 4px 10px; border-radius: 99px;
      font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 4px;
    }
    .back-btn:hover { border-color: var(--text-muted); color: var(--text-main); }

    /* Settings */
    .setting-group { margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid rgba(148,163,184,0.1); }
    .setting-group:last-child { border-bottom: none; }
    .setting-header { font-size: 13px; color: var(--text-main); margin-bottom: 8px; font-weight: 500; }
    .toggle-row { display: flex; gap: 4px; background: rgba(15,23,42,0.4); padding: 3px; border-radius: 99px; width: fit-content; border: 1px solid rgba(148,163,184,0.1); flex-wrap: wrap; }
    .toggle-btn {
      border: none; background: transparent; color: var(--text-muted);
      padding: 6px 12px; border-radius: 99px; font-size: 12px; cursor: pointer; transition: 0.2s;
    }
    .toggle-btn.active { background: var(--accent); color: #022c22; font-weight: 600; }
    
    .setting-check-btn {
      display: flex; align-items: center; justify-content: space-between;
      width: 100%; padding: 10px; border-radius: var(--radius-sm);
      background: rgba(30, 41, 59, 0.4); border: 1px solid rgba(148,163,184,0.1);
      cursor: pointer; margin-bottom: 8px; font-size: 13px; color: var(--text-muted);
    }
    .setting-check-btn.checked { background: rgba(34, 197, 94, 0.1); border-color: rgba(34, 197, 94, 0.3); color: #bbf7d0; }
    
    /* Add Card Form */
    .add-section-title { font-size: 16px; font-weight: 600; margin-bottom: 12px; color: #fff; display:flex; justify-content:space-between; align-items:center; }
    .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 24px; padding-bottom: 24px; border-bottom: 1px solid rgba(148,163,184,0.15); }
    .form-group { display: flex; flex-direction: column; gap: 6px; }
    .form-group.full { grid-column: span 2; }
    label { font-size: 12px; color: var(--text-muted); font-weight: 500; }
    input, textarea, select {
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-main); padding: 12px; border-radius: var(--radius-sm);
      font-family: inherit; font-size: 15px; outline: none;
      transition: 0.2s; width: 100%;
    }
    input:focus, textarea:focus, select:focus { border-color: var(--accent); background: rgba(15, 23, 42, 0.8); }
    .btn-submit {
      width: 100%; background: var(--accent); color: #022c22; border: none;
      padding: 14px; border-radius: var(--radius-sm); font-weight: 600; font-size: 15px;
      cursor: pointer; margin-top: 12px;
    }
    .btn-submit:hover { background: var(--accent-hover); }
    .toggle-ex-btn {
      background: transparent; border: 1px dashed rgba(148,163,184,0.3); color: var(--text-muted);
      width: 100%; padding: 8px; border-radius: var(--radius-sm); cursor: pointer; font-size: 12px;
    }
    .toggle-ex-btn:hover { border-color: var(--accent); color: var(--accent); }

    /* Words Tab Landing */
    .words-landing { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
    .big-nav-btn {
        background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(148,163,184,0.2);
        padding: 24px; border-radius: var(--radius-md);
        text-align: left; cursor: pointer; transition: 0.2s;
        display: flex; align-items: center; justify-content: space-between;
    }
    .big-nav-btn:hover { background: rgba(30,41,59,0.9); transform: translateY(-2px); border-color: var(--accent-soft); }
    .big-btn-title { font-size: 18px; font-weight: 600; color: #fff; display: block; margin-bottom: 4px; }
    .big-btn-sub { font-size: 13px; color: var(--text-muted); }

    /* Words Manager */
    .word-manager-container { margin-top: 10px; padding-bottom: 40px;}
    
    .search-row { display: flex; gap: 8px; margin-bottom: 12px; align-items: center; position: relative; }
    .search-input { flex: 1; padding: 12px; font-size: 15px; }
    .tool-btn { 
        width: 44px; height: 44px; display: flex; align-items: center; justify-content: center;
        background: rgba(15,23,42,0.6); border: 1px solid rgba(148,163,184,0.3); 
        border-radius: var(--radius-sm); color: var(--text-muted); cursor: pointer; font-size: 18px;
    }
    .tool-btn:hover { background: rgba(15,23,42,0.9); color: var(--text-main); border-color: var(--accent); }

    /* Custom Filter Dropdown */
    .filter-dropdown {
        position: absolute; top: 110%; right: 0; width: 200px;
        background: #1e293b; border: 1px solid rgba(148,163,184,0.2);
        border-radius: var(--radius-sm); box-shadow: var(--shadow-soft);
        z-index: 50; display: none; padding: 8px 0;
    }
    .filter-dropdown.show { display: block; }
    .fd-header { font-size: 11px; text-transform: uppercase; color: var(--text-muted); padding: 8px 12px 4px; letter-spacing: 0.05em; margin-top: 4px; }
    .fd-header:first-child { margin-top: 0; }
    .fd-item { padding: 8px 16px; cursor: pointer; font-size: 13px; color: var(--text-main); display: flex; justify-content: space-between; }
    .fd-item:hover { background: rgba(255,255,255,0.05); }
    .fd-item.active { color: var(--accent); font-weight: 600; }

    .btn-play-filter {
        width: 100%; background: var(--accent); color: #022c22; font-weight: 700;
        padding: 14px; border-radius: var(--radius-sm); margin-bottom: 20px;
        display: none; cursor: pointer; text-align: center; border: none;
        box-shadow: 0 4px 12px rgba(34,197,94,0.3);
    }
    .btn-play-filter:hover { background: var(--accent-hover); transform: translateY(-1px); }

    .word-list { display: flex; flex-direction: column; gap: 6px; }
    .word-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px;
      background: rgba(30,41,59,0.5); border-radius: var(--radius-sm);
      border: 1px solid rgba(148,163,184,0.1);
    }
    .word-row.bg-diff-beginner { background: rgba(34, 197, 94, 0.08); border-color: rgba(34, 197, 94, 0.1); }
    .word-row.bg-diff-basic { background: rgba(56, 189, 248, 0.08); border-color: rgba(56, 189, 248, 0.1); }
    .word-row.bg-diff-proficient { background: rgba(168, 85, 247, 0.08); border-color: rgba(168, 85, 247, 0.1); }
    .word-row.bg-diff-advanced { background: rgba(244, 63, 94, 0.08); border-color: rgba(244, 63, 94, 0.1); }
    .word-row.bg-custom { background: rgba(234, 179, 8, 0.08); border-color: rgba(234, 179, 8, 0.1); }

    .word-info { flex: 1; }
    .word-main { font-weight: 600; font-size: 14px; color: var(--text-main); }
    .word-sub { font-size: 11px; color: var(--text-muted); }
    .word-tag { font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: 6px; background: rgba(0,0,0,0.3); color: #94a3b8; }
    .word-score { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 8px; }
    .score-0 { background: #334155; }
    .score-1 { background: #fca5a5; }
    .score-3 { background: #bae6fd; }
    .score-4 { background: #4ade80; }
    
    .btn-icon { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 6px; font-size: 14px; transition: 0.2s; }
    .btn-icon:hover { color: #fff; transform: scale(1.1); }
    .btn-icon.del:hover { color: var(--danger); }
    .btn-icon.edit:hover { color: var(--gold); }

    /* TTS Button Style */
    .btn-tts {
        background: transparent; border: none; font-size: 1.2em; cursor: pointer;
        margin-right: 8px; filter: grayscale(1); transition: 0.2s;
        vertical-align: middle; display: inline-block; padding: 0;
    }
    .btn-tts:hover { filter: grayscale(0); transform: scale(1.1); }
    .btn-tts:active { transform: scale(0.9); }

    /* Game Card */
    .game-area {
      flex: 1;
      display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; min-height: 400px;
    }
    
    /* Progress Bar Styles */
    .session-progress-track {
        width: 100%; max-width: 500px; height: 6px; background: rgba(148,163,184,0.2);
        border-radius: 99px; margin-bottom: 5px; overflow: hidden;
    }
    .session-progress-fill {
        height: 100%; background: var(--accent); width: 0%;
        transition: width 0.3s ease;
    }

    .flashcard {
      width: 100%; max-width: 500px; min-height: 280px;
      background: var(--bg-gradient);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: var(--radius-lg);
      padding: 30px;
      display: flex; flex-direction: column; justify-content: space-between;
      position: relative;
      box-shadow: 0 20px 50px -12px rgba(0,0,0,0.5);
      transition: border-color 0.5s ease, box-shadow 0.5s ease;
    }
    
    /* Streak Flash Effect */
    .flashcard.streak-flash {
       background: #064e3b !important;
       transition: background 0.1s;
    }

    /* Feedback States */
    .flashcard.correct { border-color: #22c55e !important; box-shadow: 0 0 25px rgba(34, 197, 94, 0.4); }
    .flashcard.wrong { border-color: #ef4444 !important; box-shadow: 0 0 25px rgba(239, 68, 68, 0.4); }

    .card-meta { display: flex; justify-content: space-between; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 20px; align-items: center; }
    .card-main { text-align: center; flex: 1; display: flex; flex-direction: column; justify-content: center; }
    .label-lang { font-size: 11px; color: var(--text-muted); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
    .word-text { font-size: 32px; font-weight: 700; color: var(--text-main); margin-bottom: 20px; line-height: 1.2; word-break: break-word; }
    .reveal-section { border-top: 1px dashed rgba(148,163,184,0.2); padding-top: 20px; margin-top: 10px; animation: fadeIn 0.3s ease; }
    .reveal-text { font-size: 24px; font-weight: 500; color: #bae6fd; margin-bottom: 8px; }
    .examples { font-size: 14px; color: var(--text-muted); font-style: italic; line-height: 1.5; }

    /* Card Controls (Star, Edit) */
    .card-controls { display: flex; gap: 8px; }
    .card-btn { background: transparent; border: none; cursor: pointer; font-size: 18px; color: rgba(148, 163, 184, 0.5); transition: 0.2s; padding: 4px; }
    .card-btn:hover { color: var(--text-main); transform: scale(1.1); }
    .card-btn.starred { color: var(--gold); }

    /* Global Edit Modal */
    .global-edit-modal {
       position: fixed; inset: 0; background: rgba(2, 6, 23, 0.8); z-index: 200;
       display: none; align-items: center; justify-content: center; backdrop-filter: blur(4px);
    }
    .edit-box {
        background: #1e293b; padding: 24px; border-radius: var(--radius-lg);
        width: 90%; max-width: 400px; border: 1px solid rgba(148,163,184,0.2);
        display: flex; flex-direction: column; gap: 12px;
    }
    .edit-box h3 { margin: 0 0 8px 0; font-size: 16px; color: var(--text-main); }

    /* Game Actions */
    .action-row { display: flex; gap: 8px; width: 100%; max-width: 500px; }
    .btn-action {
      flex: 1; border: 1px solid rgba(148,163,184,0.2);
      background: rgba(30,41,59,0.5);
      color: var(--text-main); padding: 12px; border-radius: 99px; font-size: 14px;
      cursor: pointer; transition: 0.2s; font-weight: 500;
    }
    .btn-action:hover { background: rgba(30,41,59,0.8); transform: translateY(-1px); }
    .btn-action.primary { background: var(--text-main); color: #020617; font-weight: 600; border: none; }
    .btn-action.primary:hover { background: #e2e8f0; }
    .btn-action.success { background: var(--accent); color: #064e3b; border: none; font-weight: 600; }
    .btn-action.danger { background: rgba(239,68,68,0.2); color: #fca5a5; border-color: rgba(239,68,68,0.5); }
    .btn-action.ghost { background: transparent; border-color: transparent; color: var(--text-muted); font-size: 12px; flex: 0; white-space: nowrap; }
    .btn-action.ghost:hover { color: var(--danger); }

    .input-answer {
      width: 100%;
      background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 14px; border-radius: 99px; color: white; font-size: 16px;
      text-align: center;
      margin-bottom: 10px; outline: none;
    }
    .input-answer:focus { border-color: var(--accent); }

    /* Streak Indicator */
    .streak-container {
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        font-weight: 600;
        color: #fbbf24;
        text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        margin-top: 5px;
    }

    /* Mini In-Game Settings */
    .mini-controls { display: flex; gap: 10px; justify-content: center; width: 100%; margin-top: 5px; }
    .mini-btn {
        background: transparent;
        border: 1px solid rgba(148,163,184,0.15);
        color: var(--text-muted); font-size: 11px; padding: 6px 14px;
        border-radius: 99px; cursor: pointer; transition: 0.2s;
        text-transform: uppercase; letter-spacing: 0.5px;
    }
    .mini-btn:hover { border-color: var(--text-muted); color: var(--text-main); }
    .mini-btn.active { background: rgba(34,197,94,0.1); color: #86efac; border-color: rgba(34,197,94,0.3); }

    /* Overlay */
    .overlay { position: fixed; inset: 0; background: rgba(2, 6, 23, 0.9); z-index: 100; display: none; align-items: center; justify-content: center; backdrop-filter: blur(4px); }
    .overlay-content { background: #1e293b; padding: 30px; border-radius: var(--radius-lg); text-align: center; max-width: 90%; width: 400px; border: 1px solid rgba(148,163,184,0.2); }
    .confetti-container { position: fixed; inset: 0; pointer-events: none; z-index: 101; overflow: hidden; }
    .confetti { position: absolute; width: 8px; height: 14px; animation: fall 3s linear forwards; }
    @keyframes fall { to { transform: translateY(110vh) rotate(360deg); opacity: 0; } }

    @media (max-width: 600px) {
      .app { min-height: 100vh; border-radius: 0; border: none; }
      .flashcard { min-height: 240px; padding: 20px; }
      .word-text { font-size: 26px; }
      .form-grid { grid-template-columns: 1fr; }
      .form-group.full { grid-column: span 1; }
      .nav-tabs { justify-content: flex-start; }
      .deck-grid { grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 10px; }
      .deck-card { padding: 12px; }
    }
  </style>
</head>
<body>

<div id="loadingScreen">
  <div class="loader-content">
    <div class="loading-bar-bg"><div class="loading-bar-fill"></div></div>
    <div class="fun-fact-container">
      <div>
        <div class="fun-fact-label">Did you know?</div>
        <div class="fun-fact-text" id="funFactText">Loading facts...</div>
      </div>
    </div>
  </div>
</div>

<div class="app">
  <header class="app-header">
    <div class="header-top">
      <div class="logo-block">
        <h1>Spanish Flashcards <span class="logo-pill">PRO</span></h1>
      </div>
      <div class="header-actions">
          <button class="btn-settings" onclick="openSettings()">‚öôÔ∏è</button>
      </div>
    </div>
    
    <div style="margin-bottom:12px;">
       <p class="deck-description" id="headerDesc">Select a difficulty to begin.</p>
       <div class="stats-row">
        <div class="stat-pill accent" onclick="openWordsManagerFromHeader('known')">Known: <strong id="statKnown">0</strong></div>
        <div class="stat-pill danger" onclick="openWordsManagerFromHeader('struggle')">Struggle: <strong id="statStruggle">0</strong></div>
        <div class="stat-pill gold" onclick="openWordsManagerFromHeader('starred')">Starred: <strong id="statStarred">0</strong></div>
      </div>
    </div>

    <div class="nav-tabs">
      <button class="nav-tab active" data-panel="decks">üìö Decks</button>
      <button class="nav-tab" data-panel="game">üéÆ Play</button>
      <button class="nav-tab" data-panel="words">üóÇ Words</button>
    </div>
  </header>

  <div class="panel-container">
    
    <div id="panel-decks" class="panel active">
      <h2 class="deck-section-title">Let's start learning!</h2>
      <div id="deckBreadcrumbs" class="breadcrumbs"></div>

      <div id="personalStatsArea" class="stats-dashboard" style="display:none">
        <div class="sd-title">Your Journey</div>
        <div class="sd-grid">
           <div class="sd-item span-2" onclick="switchPanel('ranks')">
              <div class="sd-label">Mastery Rank ‚ÑπÔ∏è</div>
              <div class="sd-val" id="psRank">Novice</div>
              <div class="rank-bar"><div class="rank-fill" id="psRankBar"></div></div>
           </div>
           <div class="sd-item">
              <div class="sd-label">Word Streak</div>
              <div class="sd-val" id="psStreak">üî• 0</div>
           </div>
           <div class="sd-item">
              <div class="sd-label">Day Streak</div>
              <div class="sd-val" id="psDayStreak">üìÖ 0</div>
           </div>
        </div>
      </div>

      <div id="deckGrid" class="deck-grid">
        <div style="padding:20px; color:var(--text-muted)">Loading...</div>
      </div>
    </div>

    <!-- NEW RANK PAGE -->
    <div id="panel-ranks" class="panel">
        <div class="breadcrumbs" style="margin-bottom:15px">
           <button class="back-btn" onclick="switchPanel('decks')">‚Äπ Back to Decks</button>
        </div>
        <h2 class="deck-section-title">Mastery Ranks</h2>
        <div id="ranksListContainer" class="rank-list"></div>
    </div>

    <div id="panel-game" class="panel">
      <div class="game-area">
        <!-- Added Progress Bar -->
        <div class="session-progress-track">
           <div class="session-progress-fill" id="sessionProgressBar"></div>
        </div>

        <div class="flashcard" id="gameCard">
          <div class="card-meta">
            <div>
                <span id="gameDeckName">Deck</span> ‚Ä¢ <span id="gameStrength">New</span>
            </div>
            <div class="card-controls">
                <button class="card-btn" id="btnEditCard" onclick="openEditForCurrentCard()" title="Edit Card" style="display:none">‚úèÔ∏è</button>
                <button class="card-btn" id="btnStarCard" onclick="toggleStar()" title="Star Card">‚òÖ</button>
            </div>
          </div>
          
          <div class="card-main">
            <div class="label-lang" id="gameFrontLabel">Spanish</div>
            <div class="word-text" id="gameFrontText">Pick a deck to start</div>
            
            <div id="gameInputArea" style="display:none; width:100%;">
              <input type="text" class="input-answer" id="gameInput" placeholder="Type answer..." autocomplete="off" autocapitalize="off">
              <div id="gameFeedback" style="font-size:13px; min-height:20px;"></div>
            </div>

            <div class="reveal-section" id="gameReveal" style="display:none">
              <div class="label-lang" id="gameBackLabel">English</div>
              <div class="reveal-text" id="gameBackText">...</div>
              <div class="examples" id="gameExamples"></div>
            </div>
          </div>
        </div>
        
        <div class="action-row" id="gameControlsStart">
          <button class="btn-action ghost" id="btnDeleteCard" title="Permanently Delete">üóë Remove</button>
          <button class="btn-action primary" id="btnShowAnswer">Show Answer</button>
        </div>

        <div class="action-row" id="gameControlsJudge" style="display:none">
          <button class="btn-action danger" id="btnHard">Still Learning</button>
          <button class="btn-action success" id="btnEasy">I Knew It</button>
        </div>
        
        <div class="action-row" id="gameControlsNext" style="display:none">
            <button class="btn-action primary" id="btnNextCard">Next Card ‚û°</button>
        </div>

        <div class="streak-container" id="streakIndicator"></div>

        <div class="mini-controls" id="gameMiniControls">
            <button class="mini-btn" id="miniBtnDir" onclick="toggleGameSetting('dir')">Swap: ES ‚û° EN</button>
            <button class="mini-btn" id="miniBtnMode" onclick="toggleGameSetting('mode')">Mode: Reveal</button>
        </div>
      </div>
    </div>

    <div id="panel-words" class="panel">
      
      <div id="wordsLanding" class="words-landing">
          <button class="big-nav-btn" onclick="toggleWordSection('add')">
              <div>
                  <span class="big-btn-title">‚ûï Add New Cards</span>
                  <span class="big-btn-sub">Create your own custom flashcards</span>
              </div>
          </button>
          <button class="big-nav-btn" onclick="toggleWordSection('manage')">
              <div>
                  <span class="big-btn-title">üìÇ Manage All Words</span>
                  <span class="big-btn-sub">Search, filter, and edit your collection</span>
              </div>
          </button>
      </div>

      <div id="wordsAddSection" style="display:none">
          <div class="breadcrumbs" style="margin-bottom:15px">
             <button class="back-btn" onclick="toggleWordSection('landing')">‚Äπ Back</button>
          </div>
          <div class="add-section-title">
              <span>Add New Card</span>
          </div>
          <div class="form-grid">
            <div class="form-group">
              <label>Spanish Word</label>
              <input type="text" id="addEs" placeholder="e.g. la mesa" autocapitalize="off" autocomplete="off">
            </div>
            <div class="form-group">
              <label>English Translation</label>
              <input type="text" id="addEn" placeholder="e.g. the table" autocapitalize="off" autocomplete="off">
            </div>
            <div class="form-group full">
              <label>Category (Topic)</label>
              <select id="addTopicSelect"></select>
            </div>
            
            <div class="form-group full">
              <button type="button" class="toggle-ex-btn" id="btnToggleEx" onclick="toggleAddEx()">‚ûï Add Examples (Optional)</button>
            </div>

            <div class="form-group full" id="divAddEx" style="display:none">
              <textarea id="addExEs" placeholder="Spanish example sentence..." rows="2" autocapitalize="off"></textarea>
              <textarea id="addExEn" placeholder="English translation..." rows="2" autocapitalize="off" style="margin-top:8px"></textarea>
            </div>

            <div class="form-group full">
              <button class="btn-submit" id="btnAddSubmit">Save Card</button>
              <div id="addMsg" style="text-align:center; font-size:12px; margin-top:8px; min-height:16px;"></div>
            </div>
          </div>
      </div>
      
      <div id="wordsManageSection" style="display:none">
          <div class="breadcrumbs" style="margin-bottom:15px">
             <button class="back-btn" onclick="toggleWordSection('landing')">‚Äπ Back</button>
          </div>

          <div class="search-row">
             <input type="text" id="searchWords" class="input-answer search-input" placeholder="Search..." onkeyup="resetAndRenderWords()">
             <button class="tool-btn" onclick="toggleFilterMenu()" title="Filter">üå™</button>
             <button class="tool-btn" onclick="toggleSort()" title="Sort A-Z">Aa</button>
             
             <div class="filter-dropdown" id="filterDropdown">
                 <div class="fd-header">Status</div>
                 <div class="fd-item active" onclick="applyFilter('status', 'all')">All Status</div>
                 <div class="fd-item" onclick="applyFilter('status', 'known')">Known</div>
                 <div class="fd-item" onclick="applyFilter('status', 'struggle')">Struggle</div>
                 <div class="fd-item" onclick="applyFilter('status', 'starred')">Starred</div>
                 
                 <div class="fd-header">Category</div>
                 <div class="fd-item active" onclick="applyFilter('topic', 'all')">All Categories</div>
                 <div id="filterTopicContainer"></div>
             </div>
          </div>
          
          <button id="btnPlayFilter" class="btn-play-filter" onclick="playFilteredList()">‚ñ∂ Play These Words</button>

          <div id="wordListContainer" class="word-list word-manager-container"></div>
          
          <button id="btnShowMoreWords" class="btn-action ghost" style="width:100%; margin-top:20px; display:none" onclick="showMoreWords()">Show More</button>
      </div>
    </div>

    <div id="panel-settings" class="panel">
      <div class="breadcrumbs" style="margin-bottom:15px">
           <button class="back-btn" onclick="switchPanel('decks')">‚Äπ Back to Decks</button>
      </div>
      
      <div id="settings-main">
        <div class="setting-group">
          <div class="setting-header">Custom Content</div>
          <div class="setting-check-btn" id="btnToggleIncludeCustom" onclick="toggleSetting('includeCustom')">
              <span>Include my added words in decks</span>
              <span class="status-icon">‚úì</span>
          </div>
          <div class="setting-check-btn" id="btnToggleOnlyCustom" onclick="toggleSetting('onlyCustom')">
              <span>Play ONLY my added words</span>
              <span class="status-icon">‚óã</span>
          </div>
        </div>

        <div class="setting-group">
          <div class="setting-header">Practice Direction</div>
          <div class="toggle-row">
            <button class="toggle-btn active" data-group="dir" data-val="es-en">Spanish ‚Üí English</button>
            <button class="toggle-btn" data-group="dir" data-val="en-es">English ‚Üí Spanish</button>
          </div>
        </div>

        <div class="setting-group">
          <div class="setting-header">Answer Mode</div>
          <div class="toggle-row">
            <button class="toggle-btn active" data-group="mode" data-val="reveal">Self Check</button>
            <button class="toggle-btn" data-group="mode" data-val="type">Type Answer</button>
          </div>
        </div>

        <div class="setting-group">
          <div class="setting-header">Data</div>
          <button class="btn-action danger" id="btnResetData" style="width:100%">Reset All Progress</button>
        </div>
      </div>
    </div>

  </div>

  <div class="overlay" id="overlay">
    <div class="overlay-content">
      <h2 style="margin-top:0">üéâ Deck Complete!</h2>
      <div style="display:flex; justify-content:center; gap:10px; margin-bottom:20px;">
        <div class="stat-pill accent">Mastered: <strong id="resCorrect">0</strong></div>
        <div class="stat-pill danger">Struggled: <strong id="resStruggle">0</strong></div>
      </div>
      <button class="btn-action primary" onclick="closeOverlay()">Back to Decks</button>
      <button class="btn-action danger" id="btnPracticeStruggle" style="margin-top:10px" onclick="startPracticeStruggle()">Practice Struggle Words</button>
    </div>
  </div>
  
  <!-- New Resume Modal -->
  <div class="overlay" id="resumeModal">
    <div class="overlay-content">
      <h2 style="margin-top:0">Welcome Back! üëã</h2>
      <p style="color:var(--text-muted); font-size:14px; line-height:1.5; margin-bottom:20px;">
          It's been <strong id="resumeDays" style="color:#fff">0 day(s)</strong> since you played this deck. 
          Want to refresh your mind by starting over, or continue from where you left off?
      </p>
      <div style="display:flex; flex-direction:column; gap:10px;">
        <button class="btn-action success" onclick="confirmStartSession(true)">Continue from here</button>
        <button class="btn-action ghost" onclick="confirmStartSession(false)">Start Over</button>
      </div>
    </div>
  </div>

  <!-- Missing Voice Modal -->
  <div class="overlay" id="noVoiceModal">
    <div class="overlay-content">
      <h2 style="margin-top:0">‚ö†Ô∏è No Spanish Voice Found</h2>
      <p style="color:var(--text-muted); font-size:14px; line-height:1.5; margin-bottom:20px;">
          Your device doesn't have a Spanish voice installed.
      </p>
      <div style="background:rgba(255,255,255,0.1); padding:15px; border-radius:8px; text-align:left; font-size:13px; margin-bottom:20px; color:#fff;">
          <strong>How to fix:</strong><br>
          1. Go to device <b>Settings</b>.<br>
          2. Search for <b>"Text-to-speech"</b> or <b>"Spoken Content"</b>.<br>
          3. Download a <b>Spanish</b> voice package.
      </div>
      <button class="btn-action primary" onclick="document.getElementById('noVoiceModal').style.display='none'">Okay, I'll check</button>
    </div>
  </div>

  <div class="global-edit-modal" id="globalEditModal">
      <div class="edit-box">
          <h3>Edit Card</h3>
          <label>Spanish</label>
          <input type="text" id="globalEditEs">
          <label>English</label>
          <input type="text" id="globalEditEn">
          <div class="action-row" style="margin-top:10px">
              <button class="btn-action ghost" onclick="closeEditModal()">Cancel</button>
              <button class="btn-action primary" onclick="saveGlobalEdit()">Save Changes</button>
          </div>
      </div>
  </div>

  <div id="rankNotification" class="notification-banner">
      <div class="notif-icon">üèÜ</div>
      <div class="notif-text">Rank Up! You are now a <span id="notifRankName">Master</span>!</div>
  </div>

</div>

<script>
/**
 * APP LOGIC
 */
const STATE = {
  decksRaw: [],
  activeDecks: [],
  customCards: {}, 
  progress: {}, 
  blacklist: new Set(),
  starred: new Set(),
  struggleList: new Set(), 
  deckProgress: {}, 
  
  // Persistence for Day Streak
  dayStreak: 0,
  lastActiveDate: null,
  lastRankIndex: 0,

  // Session State
  sessionData: {}, 
  sessionStats: { correctFirst: 0, struggle: 0 },
  sessionStruggleIds: [], 
  customSessionList: null, 
  lastCardUid: null,
  streak: 0, 
  
  // Navigation
  view: 'root', 
  selDiff: null,
  selLevel: null,
  
  // Words Manager State
  wordManagerLimit: 25,
  activeFilter: { status: 'all', topic: 'all' },
  sortAsc: true,

  // Game Config
  currentDeckId: null,
  currentCard: null,
  isStruggleMode: false,
  
  // Settings
  direction: 'es-en',
  mode: 'reveal',
  includeCustom: true,
  onlyCustom: false
};

const RANKS = [
    { name: "Novice", limit: 20, icon: "üë∂" },
    { name: "Apprentice", limit: 50, icon: "üå±" },
    { name: "Scholar", limit: 100, icon: "üìö" },
    { name: "Expert", limit: 300, icon: "üéì" },
    { name: "Master", limit: 600, icon: "ü¶Å" },
    { name: "Grandmaster", limit: 1000, icon: "üëë" }
];

let editingCardUid = null;
let loadStartTime = Date.now();
// Temporary holding variable for deck start flow
let pendingDeckId = null;
let pendingIsMix = false;

// TTS Variables
let spanishVoices = [];

const FUN_FACTS = [
    "Spanish is the second most spoken native language in the world, beating English!",
    "The letter '√±' is the only letter of Spanish origin.",
    "Spanish was once known as 'the Christian' (cristiano) in Spain.",
    "Exclamation and question marks are used upside down (¬°Hola!).",
    "Spanish is a Romance language, coming from Latin.",
    "The United States has more Spanish speakers than Spain!",
    "The most common letter in Spanish is 'e'.",
    "Arabic influenced Spanish heavily: words like 'az√∫car' come from Arabic.",
    "The Royal Spanish Academy (RAE) has regulated the language since 1713.",
    "Spanish is the official language in 20 different countries."
];

let factInterval;

// --- INIT ---
async function init() {
  loadStartTime = Date.now();
  startLoadingScreen();
  loadLocalData();
  await loadRemoteData();
  populateTopicFilter(); 
  bindEvents();
  renderDecks();
  updateStats();
  updateGameMiniSettings();
  initTTS(); // Initialize Text to Speech
}

// --- LOADING SCREEN ---
function startLoadingScreen() {
    const textEl = document.getElementById('funFactText');
    textEl.textContent = FUN_FACTS[Math.floor(Math.random() * FUN_FACTS.length)];
    factInterval = setInterval(() => {
        textEl.style.opacity = '0';
        setTimeout(() => {
            textEl.textContent = FUN_FACTS[Math.floor(Math.random() * FUN_FACTS.length)];
            textEl.style.opacity = '1';
        }, 500);
    }, 6000);
}

function hideLoadingScreen() {
    const elapsed = Date.now() - loadStartTime;
    const remaining = Math.max(0, 2000 - elapsed); // Force 2s minimum

    setTimeout(() => {
        const screen = document.getElementById('loadingScreen');
        screen.style.opacity = '0';
        screen.style.pointerEvents = 'none';
        clearInterval(factInterval);
        setTimeout(() => { screen.style.display = 'none'; }, 500);
    }, remaining);
}

// --- TTS LOGIC ---
function initTTS() {
    const load = () => {
        const all = window.speechSynthesis.getVoices();
        spanishVoices = all.filter(v => v.lang.startsWith('es'));
    };
    // Chrome loads voices asynchronously
    if (window.speechSynthesis.onvoiceschanged !== undefined) {
        window.speechSynthesis.onvoiceschanged = load;
    }
    load();
}

function getBestVoice() {
    if (spanishVoices.length === 0) return null;
    // Priority: Google -> Premium -> Default
    const google = spanishVoices.find(v => v.name.includes('Google'));
    if (google) return google;
    const premium = spanishVoices.find(v => v.name.includes('Premium') || v.name.includes('Enhanced'));
    if (premium) return premium;
    return spanishVoices[0];
}

function speakSpanish(text) {
    if (spanishVoices.length === 0) {
        // Try reloading just in case the async load was slow
        const all = window.speechSynthesis.getVoices();
        spanishVoices = all.filter(v => v.lang.startsWith('es'));
    }

    if (spanishVoices.length === 0) {
        document.getElementById('noVoiceModal').style.display = 'flex';
        return;
    }

    // Stop current speech
    window.speechSynthesis.cancel();

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.voice = getBestVoice();
    utterance.rate = 0.9; // Slightly slower is usually better for learning
    window.speechSynthesis.speak(utterance);
}

// --- DATA HANDLING ---
async function loadRemoteData() {
  try {
    const res = await fetch('decks.json');
    if(!res.ok) throw new Error("404");
    const json = await res.json();
    STATE.decksRaw = json;
    STATE.activeDecks = json.decks.map(d => ({ ...d, cards: [...d.cards] }));
    injectCustomCards();
    renderDecks();
    hideLoadingScreen();
  } catch (e) {
    document.getElementById('deckGrid').innerHTML = `<div style="padding:20px; color:#fca5a5">Error loading decks.json.</div>`;
    hideLoadingScreen();
  }
}

function loadLocalData() {
  const custom = localStorage.getItem('sf_custom');
  if(custom) STATE.customCards = JSON.parse(custom);

  const prog = localStorage.getItem('sf_progress');
  if(prog) STATE.progress = JSON.parse(prog);
  
  // Load deck saves
  const dp = localStorage.getItem('sf_deck_progress');
  if(dp) STATE.deckProgress = JSON.parse(dp);

  const black = localStorage.getItem('sf_blacklist');
  if(black) STATE.blacklist = new Set(JSON.parse(black));
  
  const starred = localStorage.getItem('sf_starred');
  if(starred) STATE.starred = new Set(JSON.parse(starred));

  const struggle = localStorage.getItem('sf_struggle');
  if(struggle) STATE.struggleList = new Set(JSON.parse(struggle));

  const settings = JSON.parse(localStorage.getItem('sf_settings') || '{}');
  if(settings.dir) changeToggle('dir', settings.dir, false);
  if(settings.mode) changeToggle('mode', settings.mode, false);
  STATE.includeCustom = settings.includeCustom !== false;
  STATE.onlyCustom = settings.onlyCustom === true;
  if(settings.selDiff) STATE.selDiff = settings.selDiff;

  // Streak Data
  STATE.dayStreak = parseInt(localStorage.getItem('sf_dayStreak') || '0');
  STATE.lastActiveDate = localStorage.getItem('sf_lastActiveDate');
  STATE.lastRankIndex = parseInt(localStorage.getItem('sf_lastRankIndex') || '0');

  updateCheckUI('includeCustom', STATE.includeCustom);
  updateCheckUI('onlyCustom', STATE.onlyCustom);
}

function saveData() {
  localStorage.setItem('sf_custom', JSON.stringify(STATE.customCards));
  localStorage.setItem('sf_progress', JSON.stringify(STATE.progress));
  localStorage.setItem('sf_deck_progress', JSON.stringify(STATE.deckProgress));
  localStorage.setItem('sf_blacklist', JSON.stringify([...STATE.blacklist]));
  localStorage.setItem('sf_starred', JSON.stringify([...STATE.starred]));
  localStorage.setItem('sf_struggle', JSON.stringify([...STATE.struggleList]));
  
  localStorage.setItem('sf_dayStreak', STATE.dayStreak.toString());
  if(STATE.lastActiveDate) localStorage.setItem('sf_lastActiveDate', STATE.lastActiveDate);
  localStorage.setItem('sf_lastRankIndex', STATE.lastRankIndex.toString());

  const settings = {
    dir: STATE.direction,
    mode: STATE.mode,
    includeCustom: STATE.includeCustom,
    onlyCustom: STATE.onlyCustom,
    selDiff: STATE.selDiff
  };
  localStorage.setItem('sf_settings', JSON.stringify(settings));
}

function injectCustomCards() {
  STATE.activeDecks.forEach(deck => {
    const topicCards = STATE.customCards[deck.topicId] || [];
    topicCards.forEach(c => {
       const exists = deck.cards.find(ex => ex.es === c.es && ex._custom);
       if(!exists) deck.cards.push(c);
       else {
           Object.assign(exists, c);
       }
    });
  });
}

// --- DECK NAVIGATION UI ---
const domGrid = document.getElementById('deckGrid');
const domBread = document.getElementById('deckBreadcrumbs');
const domHeaderDesc = document.getElementById('headerDesc');

function getDifficultyIcon(label) {
    const l = label.toLowerCase();
    if(l.includes('beginner')) return 'üê£';
    if(l.includes('basic')) return 'üå±';
    if(l.includes('intermediate')) return 'üßó';
    if(l.includes('proficient')) return 'üöÄ';
    if(l.includes('advanced')) return 'üß†';
    return 'üéì';
}

function getTopicEmoji(topicId) {
    const map = {
        'verbs': 'üèÉ', 'everyday-nouns': 'üì¶', 'adjectives': '‚ú®', 'phrases': 'üí¨', 'time-numbers': '‚è∞'
    };
    return map[topicId] || 'üìù';
}

function renderDecks() {
  domGrid.innerHTML = '';
  domBread.innerHTML = '';
  const personalStats = document.getElementById('personalStatsArea');

  if(!STATE.selDiff) {
    domHeaderDesc.textContent = "Select your difficulty level.";
    personalStats.style.display = 'block';
    updatePersonalStatsUI();
    
    if(!STATE.decksRaw.difficulties) return;
    
    if(STATE.starred.size > 0) {
        const starEl = createCard('‚≠ê', 'Starred Words', `${STATE.starred.size} cards`, () => {
             openWordsManagerFromHeader('starred');
        });
        starEl.classList.add('mastered-gold');
        domGrid.appendChild(starEl);
    }

    // --- NEW: Struggle Words Deck ---
    if(STATE.struggleList.size > 0) {
        const struggleEl = createCard('üßó', 'Struggle Words', `${STATE.struggleList.size} cards`, () => {
             openWordsManagerFromHeader('struggle');
        });
        struggleEl.classList.add('mastered-red');
        domGrid.appendChild(struggleEl);
    }

    STATE.decksRaw.difficulties.forEach(diff => {
      const status = checkDifficultyCompletion(diff.id);
      const el = document.createElement('div');
      el.className = 'deck-card diff-card';
      if(status === 'gold') el.classList.add('mastered-gold');
      else if(status === 'green') el.classList.add('mastered-green');

      el.innerHTML = `
        <div class="diff-emoji">${getDifficultyIcon(diff.label)}</div>
        <div class="diff-text-col">
            <div class="diff-title">${diff.label}</div>
            <div class="diff-sub">Difficulty</div>
        </div>
      `;
      el.onclick = () => {
        STATE.selDiff = diff.id;
        STATE.view = 'level';
        saveData();
        renderDecks();
      };
      domGrid.appendChild(el);
    });
    return;
  }

  personalStats.style.display = 'none';
  const diffObj = STATE.decksRaw.difficulties.find(d => d.id === STATE.selDiff);
  
  if(STATE.selDiff && !STATE.selLevel) {
    domHeaderDesc.textContent = `Select a level in ${diffObj.label}.`;
    addBreadcrumb("Difficulties", () => { STATE.selDiff = null; renderDecks(); });
    
    const levels = new Set(STATE.activeDecks.filter(d => d.difficultyId === STATE.selDiff).map(d => d.levelIndex));
    [...levels].sort().forEach(lvl => {
      const status = checkLevelCompletion(STATE.selDiff, lvl);
      const el = createCard('üì∂', `Level ${lvl}`, `${diffObj.label}`, () => {
        STATE.selLevel = lvl;
        renderDecks();
      });
      if(status === 'gold') el.classList.add('mastered-gold');
      else if(status === 'green') el.classList.add('mastered-green');
      domGrid.appendChild(el);
    });
    return;
  }

  if(STATE.selDiff && STATE.selLevel) {
    domHeaderDesc.textContent = `Pick a topic to study.`;
    addBreadcrumb("Difficulties", () => { STATE.selDiff = null; STATE.selLevel = null; renderDecks(); });
    addBreadcrumb(`Level ${STATE.selLevel}`, () => { STATE.selLevel = null; renderDecks(); });

    const decks = STATE.activeDecks.filter(d => d.difficultyId === STATE.selDiff && d.levelIndex === STATE.selLevel);
    let mixCount = 0;
    decks.forEach(d => { mixCount += getPlayableCount(d); });
    const levelStatus = checkLevelCompletion(STATE.selDiff, STATE.selLevel);
    
    const mixEl = createCard('‚ö°', "Mix All Topics", `${mixCount} cards`, () => { startSession(null, true); });
    mixEl.classList.add('active');
    if(levelStatus === 'gold') mixEl.classList.add('mastered-gold');
    else if(levelStatus === 'green') mixEl.classList.add('mastered-green');
    domGrid.appendChild(mixEl);

    decks.forEach(d => {
      const topic = STATE.decksRaw.topics.find(t => t.id === d.topicId);
      const label = topic ? topic.label : d.name;
      const count = getPlayableCount(d);
      const status = checkDeckCompletion(d);
      const icon = getTopicEmoji(d.topicId);
      
      // Calculate specific stats for this deck to render indicators
      const stats = getDeckStats(d);

      const el = createCard(icon, label, `${count} cards`, () => { startSession(d.id); }, stats);
      if(status === 'gold') el.classList.add('mastered-gold');
      else if(status === 'green') el.classList.add('mastered-green');
      domGrid.appendChild(el);
    });
  }
}

// --- STATS UI & RANKS ---
function getKnownWordCount() {
    let known = 0;
    const isEs = STATE.direction === 'es-en';
    Object.entries(STATE.progress).forEach(([uid, p]) => {
        if(STATE.blacklist.has(uid)) return;
        const score = isEs ? (p.scoreEsEn||0) : (p.scoreEnEs||0);
        if(score >= 4) known++;
    });
    return known;
}

function updatePersonalStatsUI() {
    const known = getKnownWordCount();
    let currentRankIndex = 0;
    
    for(let i=0; i<RANKS.length; i++) {
        if(known >= RANKS[i].limit) {
            currentRankIndex = i;
        } else { break; }
    }

    // Detect Rank Up
    if(currentRankIndex > STATE.lastRankIndex) {
        STATE.lastRankIndex = currentRankIndex;
        saveData();
        showRankNotification(RANKS[currentRankIndex].name);
    }

    const currentRank = RANKS[currentRankIndex];
    const nextRank = RANKS[currentRankIndex + 1];
    const prevLimit = currentRank.limit; // Or actually the limit of previous to calc progress bar correctly

    document.getElementById('psRank').textContent = currentRank.name;
    document.getElementById('psStreak').textContent = `üî• ${STATE.streak}`;
    document.getElementById('psDayStreak').textContent = `üìÖ ${STATE.dayStreak}`;

    if(nextRank) {
        // Correct calculation for progress within current tier
        // E.g. Novice ends at 20. Apprentice ends at 50.
        // If I have 25 words. I am 5 words into the 30 word gap.
        const gap = nextRank.limit - currentRank.limit; 
        const progressInGap = known - currentRank.limit;
        const percent = Math.min(100, Math.max(0, (progressInGap / gap) * 100));
        document.getElementById('psRankBar').style.width = `${percent}%`;
    } else {
        document.getElementById('psRankBar').style.width = `100%`;
    }
}

function showRankNotification(rankName) {
    const el = document.getElementById('rankNotification');
    document.getElementById('notifRankName').textContent = rankName;
    el.classList.add('show');
    setTimeout(() => {
        el.classList.remove('show');
    }, 4000);
}

function renderRanksPanel() {
    const container = document.getElementById('ranksListContainer');
    container.innerHTML = '';
    
    const known = getKnownWordCount();
    
    RANKS.forEach((rank, index) => {
        const item = document.createElement('div');
        
        let statusClass = '';
        let isCompleted = known >= rank.limit;
        
        let isCurrent = false;
        if (index === 0 && known < RANKS[1].limit) isCurrent = true;
        else if (known >= rank.limit && (!RANKS[index+1] || known < RANKS[index+1].limit)) {
            isCurrent = true;
        } else if (known >= rank.limit) {
            statusClass = 'completed';
        } else {
            statusClass = 'locked';
        }
        
        if(isCurrent) statusClass = 'current';

        // Progress calc
        let progressPct = 0;
        if(known >= rank.limit) progressPct = 100;
        else {
            progressPct = Math.min(100, (known / rank.limit) * 100);
        }

        item.className = `rank-card-item ${statusClass}`;
        item.innerHTML = `
            <div class="rank-icon-large">${rank.icon}</div>
            <div class="rank-info-col">
                <div style="display:flex; justify-content:space-between;">
                    <div class="rank-name-title">${rank.name}</div>
                    <div style="font-size:11px; color:var(--text-muted)">${known} / ${rank.limit}</div>
                </div>
                <div class="rank-desc">${isCurrent ? "Current Rank" : (statusClass==='completed' ? "Completed" : "Locked")}</div>
                <div class="rank-progress-wrap">
                    <div class="rank-progress-bar" style="width:${progressPct}%"></div>
                </div>
            </div>
        `;
        container.appendChild(item);
    });
}

function getMasteryStatusForCards(cards, deckIdRef) {
    const coreCards = cards.filter(c => !c._custom);
    if(coreCards.length === 0) return null; 
    let allEsEn = true, allEnEs = true;
    coreCards.forEach(c => {
        const uid = getCardId(c._realDeckId || deckIdRef, c);
        const p = STATE.progress[uid] || {};
        if((p.scoreEsEn || 0) < 4) allEsEn = false;
        if((p.scoreEnEs || 0) < 4) allEnEs = false;
    });
    if(allEsEn && allEnEs) return 'gold';
    if(allEsEn || allEnEs) return 'green';
    return null;
}

function getDeckStats(deck) {
    const coreCards = deck.cards.filter(c => !c._custom);
    if(coreCards.length === 0) return { esen: false, enes: false, percent: 0 };

    let countEsEn = 0;
    let countEnEs = 0;
    
    coreCards.forEach(c => {
        const uid = getCardId(deck.id, c);
        const p = STATE.progress[uid] || {};
        if((p.scoreEsEn || 0) >= 4) countEsEn++;
        if((p.scoreEnEs || 0) >= 4) countEnEs++;
    });

    const totalPoss = coreCards.length * 2;
    const current = countEsEn + countEnEs;
    const pct = Math.round((current / totalPoss) * 100);

    return {
        esen: countEsEn === coreCards.length,
        enes: countEnEs === coreCards.length,
        percent: pct
    };
}

function checkDeckCompletion(deck) { return getMasteryStatusForCards(deck.cards, deck.id); }
function checkLevelCompletion(diffId, levelIdx) {
    const decks = STATE.activeDecks.filter(d => d.difficultyId === diffId && d.levelIndex === levelIdx);
    if(decks.length === 0) return null;
    const allCards = decks.flatMap(d => d.cards.map(c => ({...c, _realDeckId: d.id})));
    return getMasteryStatusForCards(allCards, null);
}
function checkDifficultyCompletion(diffId) {
    const decks = STATE.activeDecks.filter(d => d.difficultyId === diffId);
    if(decks.length === 0) return null;
    const allCards = decks.flatMap(d => d.cards.map(c => ({...c, _realDeckId: d.id})));
    return getMasteryStatusForCards(allCards, null);
}

function createCard(icon, title, sub, onClick, stats = null) {
  const div = document.createElement('div');
  div.className = 'deck-card';
  
  let html = `<div class="deck-icon">${icon}</div><div class="deck-title">${title}</div>`;
  
  // Add Progress Bar and Indicators if stats exist
  if (stats) {
      html += `
        <div class="deck-progress-track">
            <div class="deck-progress-fill" style="width:${stats.percent}%"></div>
        </div>
        <div class="dir-indicators">
            <div class="dir-box ${stats.esen ? 'completed' : ''}">ES‚ÜíEN</div>
            <div class="dir-box ${stats.enes ? 'completed' : ''}">EN‚ÜíES</div>
        </div>
      `;
  }
  
  html += `<div class="deck-count">${sub}</div>`;
  div.innerHTML = html;
  div.onclick = onClick;
  return div;
}

function addBreadcrumb(label, onClick) {
  const btn = document.createElement('button');
  btn.className = 'back-btn';
  btn.innerHTML = `‚Äπ ${label}`;
  btn.onclick = onClick;
  domBread.appendChild(btn);
}

function getPlayableCount(deck) {
  return deck.cards.filter(c => {
    const id = getCardId(deck.id, c);
    if(STATE.blacklist.has(id)) return false;
    if(STATE.onlyCustom && !c._custom) return false;
    if(!STATE.includeCustom && c._custom) return false;
    return true;
  }).length;
}

// --- GAME LOGIC ---

// New Logic: Check for save state
function startSession(deckId, isMix = false) {
    pendingDeckId = deckId;
    pendingIsMix = isMix;

    // Construct a save key for this specific deck/mix configuration
    const saveKey = isMix ? `mix_${STATE.selDiff}_${STATE.selLevel}` : deckId;
    
    // Check if we have saved progress
    if(STATE.deckProgress[saveKey]) {
        const last = STATE.deckProgress[saveKey].lastPlayed;
        const now = Date.now();
        const days = Math.floor((now - last) / (1000 * 60 * 60 * 24));

        if(days >= 1) {
            // > 1 Day: Ask user
            document.getElementById('resumeDays').textContent = days + (days === 1 ? ' day' : ' days');
            document.getElementById('resumeModal').style.display = 'flex';
            return;
        } else {
            // < 1 Day: Auto Resume
            confirmStartSession(true);
            return;
        }
    }

    // No save: Start Fresh
    confirmStartSession(false);
}

function confirmStartSession(resume) {
    document.getElementById('resumeModal').style.display = 'none';
    const deckId = pendingDeckId;
    const isMix = pendingIsMix;
    const saveKey = isMix ? `mix_${STATE.selDiff}_${STATE.selLevel}` : deckId;

    STATE.currentDeckId = deckId;
    STATE.isStruggleMode = false;
    STATE.customSessionList = null;
    STATE.lastCardUid = null;
    STATE.streak = 0;
    STATE.sessionStats = { correctFirst: 0, struggle: 0 };
    STATE.sessionData = {}; // Clear memory

    if(resume && STATE.deckProgress[saveKey]) {
        // Hydrate session data from save
        const savedUids = STATE.deckProgress[saveKey].correctUids || [];
        savedUids.forEach(uid => {
            STATE.sessionData[uid] = { count: 1, correctInSession: true }; // Mark as done
        });
    } else {
        // Start fresh: Clear save
        if(STATE.deckProgress[saveKey]) {
            delete STATE.deckProgress[saveKey];
            saveData();
        }
    }

    if(!isMix && !deckId) return;
    const pool = getPoolFromCurrentSession();
    if(pool.length === 0) { alert("No cards available!"); return; }
    
    switchPanel('game');
    updateProgressBar(pool.length); // Init bar
    nextCard();
}

function startPracticeStruggle() {
  if(STATE.sessionStruggleIds.length === 0) return;  
  STATE.sessionData = {}; 
  STATE.isStruggleMode = true;
  STATE.lastCardUid = null;
  STATE.streak = 0;  
  document.getElementById('overlay').style.display = 'none';
  
  // Progress bar for struggle mode is simple (0 to start)
  updateProgressBar(STATE.sessionStruggleIds.length);
  
  nextCard();
}

function startFilteredSession(uidList) {
    STATE.currentDeckId = null;
    STATE.customSessionList = uidList;
    STATE.sessionData = {};
    STATE.lastCardUid = null;
    STATE.isStruggleMode = false;
    STATE.sessionStats = { correctFirst: 0, struggle: 0 };
    STATE.sessionStruggleIds = [];
    STATE.streak = 0;
    
    if(uidList.length === 0) { alert("No cards in list."); return; }
    switchPanel('game');
    updateProgressBar(uidList.length);
    nextCard();
}

function updateProgressBar(totalOverride = null) {
    // Determine context total and current
    let total = 0;
    let current = 0;

    if(STATE.customSessionList) {
        total = STATE.customSessionList.length;
        current = STATE.customSessionList.filter(uid => STATE.sessionData[uid]?.correctInSession).length;
    } else if (STATE.isStruggleMode) {
        // In struggle mode, total is the starting list, current is how many correct now
        total = totalOverride || STATE.sessionStruggleIds.length; 
        // We need to track how many removed from struggle list effectively
        // Actually simpler: 
        current = Object.values(STATE.sessionData).filter(d => d.correctInSession).length;
    } else {
        // Normal Session
        // Total is pool size + already done
        // We need to re-calculate total pool including those filtered out
        const isMix = !STATE.currentDeckId;
        const relevantDecks = isMix 
            ? STATE.activeDecks.filter(d => d.difficultyId === STATE.selDiff && d.levelIndex === STATE.selLevel)
            : [STATE.activeDecks.find(d => d.id === STATE.currentDeckId)];
            
        let validCardsCount = 0;
        relevantDecks.forEach(d => {
            if(!d) return;
            d.cards.forEach(c => {
                const uid = getCardId(d.id, c);
                if(STATE.blacklist.has(uid)) return;
                if(STATE.onlyCustom && !c._custom) return;
                if(!STATE.includeCustom && c._custom) return;
                validCardsCount++;
            });
        });
        total = validCardsCount;
        current = Object.values(STATE.sessionData).filter(d => d.correctInSession).length;
    }

    const pct = total === 0 ? 0 : Math.round((current / total) * 100);
    document.getElementById('sessionProgressBar').style.width = `${pct}%`;
}

function nextCard() {
  let pool = [];
  
  // 1. Get the pool of cards based on the current mode
  if (STATE.customSessionList) {
      const allDecks = STATE.activeDecks;
      pool = [];
      STATE.customSessionList.forEach(uid => {
          const parts = uid.split(':');
          const deckId = parts[0];
          const esKey = parts.slice(1).join(':');
          const deck = allDecks.find(d => d.id === deckId);
          if(deck) {
              const card = deck.cards.find(c => c.es.replace(/\s/g,'') === esKey);
              if(card) pool.push({ ...card, _realDeckId: deckId, _uid: uid });
          }
      });
  } else if(STATE.isStruggleMode) {
    STATE.activeDecks.forEach(d => {
      d.cards.forEach(c => {
         const uid = getCardId(d.id, c);
         if(STATE.sessionStruggleIds.includes(uid)) {
           pool.push({ ...c, _realDeckId: d.id, _uid: uid });
         }
      });
    });
  } else {
    pool = getPoolFromCurrentSession();
  }
  
  // 2. Filter: Keep cards that are NOT yet marked correct in this specific session
  const remaining = pool.filter(c => {
    const sData = STATE.sessionData[c._uid];
    if (!sData) return true;
    return sData.correctInSession !== true;
  });

  // Update Progress Bar
  updateProgressBar();

  // 3. Check for Completion
  if(remaining.length === 0) { 
      // Clear saved progress for this deck since we finished it
      if(!STATE.isStruggleMode && !STATE.customSessionList) {
        const isMix = !STATE.currentDeckId;
        const saveKey = isMix ? `mix_${STATE.selDiff}_${STATE.selLevel}` : STATE.currentDeckId;
        if(STATE.deckProgress[saveKey]) {
            delete STATE.deckProgress[saveKey];
            saveData();
        }
      }
      showDeckComplete(); 
      return; 
  }
  
  // 4. Constraint: Don't show the same card twice in a row, UNLESS it is the only card left
  let candidates = remaining.filter(c => c._uid !== STATE.lastCardUid);
  
  if (candidates.length === 0) {
      candidates = remaining;
  }
  
  // 5. Pick and Render
  const card = candidates[Math.floor(Math.random() * candidates.length)];
  STATE.currentCard = card;
  STATE.lastCardUid = card._uid;
  renderGameCard();
}

function getPoolFromCurrentSession() {
  let pool = [];
  const isMix = !STATE.currentDeckId;
  const relevantDecks = isMix 
    ? STATE.activeDecks.filter(d => d.difficultyId === STATE.selDiff && d.levelIndex === STATE.selLevel)
    : [STATE.activeDecks.find(d => d.id === STATE.currentDeckId)];
  
  relevantDecks.forEach(d => {
    if(!d) return;
    d.cards.forEach((c, idx) => {
      const uid = getCardId(d.id, c);
      if(STATE.blacklist.has(uid)) return;
      if(STATE.onlyCustom && !c._custom) return;
      if(!STATE.includeCustom && c._custom) return;
      pool.push({ ...c, _realDeckId: d.id, _realIndex: idx, _uid: uid });
    });
  });
  return pool;
}

function renderGameCard() {
  const c = STATE.currentCard;
  const isEs = STATE.direction === 'es-en';
  
  document.getElementById('gameReveal').style.display = 'none';
  document.getElementById('gameControlsJudge').style.display = 'none';
  document.getElementById('gameControlsNext').style.display = 'none';
  document.getElementById('gameControlsStart').style.display = 'flex';
  document.getElementById('btnShowAnswer').style.display = 'block';

  const btnEdit = document.getElementById('btnEditCard');
  if(c._custom) btnEdit.style.display = 'block';
  else btnEdit.style.display = 'none';

  const btnStar = document.getElementById('btnStarCard');
  if(STATE.starred.has(c._uid)) btnStar.classList.add('starred');
  else btnStar.classList.remove('starred');

  const input = document.getElementById('gameInput');
  input.value = '';
  document.getElementById('gameFeedback').textContent = '';
  
  if (STATE.mode === 'type') {
      document.getElementById('gameInputArea').style.display = 'block';
      input.focus();
      setTimeout(() => input.focus(), 10);
  } else {
      document.getElementById('gameInputArea').style.display = 'none';
  }
  document.getElementById('gameMiniControls').style.display = 'flex';

  const streakEl = document.getElementById('streakIndicator');
  if(STATE.streak >= 2) streakEl.textContent = `üî• ${STATE.streak}`;
  else streakEl.textContent = '';

  const deckName = STATE.activeDecks.find(d => d.id === c._realDeckId)?.name || "";
  document.getElementById('gameDeckName').textContent = deckName;
  
  const p = STATE.progress[c._uid] || {};
  const score = isEs ? (p.scoreEsEn || 0) : (p.scoreEnEs || 0);

  let strLabel = "New Word";
  if(score > 0) strLabel = "Learning";
  if(score >= 4) strLabel = "Mastered";
  document.getElementById('gameStrength').textContent = strLabel;
  
  document.getElementById('gameFrontLabel').textContent = isEs ? "Spanish" : "English";
  
  // --- UPDATED TTS LOGIC FOR GAME CARD ---
  // If direction is ES->EN, the front text is Spanish.
  // If direction is EN->ES, the front text is English.
  
  const frontText = isEs ? c.es : c.en;
  // Use replace to escape single quotes in JS call
  const cleanEs = c.es.replace(/'/g, "\\'");
  
  let frontHtml = frontText;
  if(isEs) {
      // Front is Spanish -> Add TTS
      frontHtml = `<button class="btn-tts" onclick="speakSpanish('${cleanEs}')" title="Listen">üîä</button> ${c.es}`;
  }
  document.getElementById('gameFrontText').innerHTML = frontHtml;
  
  document.getElementById('gameBackLabel').textContent = isEs ? "English" : "Spanish";
  
  const backText = isEs ? c.en : c.es;
  let backHtml = backText;
  if(!isEs) {
      // Back is Spanish (EN->ES mode) -> Add TTS
      backHtml = `<button class="btn-tts" onclick="speakSpanish('${cleanEs}')" title="Listen">üîä</button> ${c.es}`;
  }
  document.getElementById('gameBackText').innerHTML = backHtml;
  
  let ex = "";
  if(c.exampleEs && c.exampleEn) { ex = `"${c.exampleEs}"<br>"${c.exampleEn}"`; }
  document.getElementById('gameExamples').innerHTML = ex;
}

function cleanText(str) {
    let s = str.replace(/\s*\(.*?\)/g, "");
    s = s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    s = s.toLowerCase();
    s = s.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()¬ø¬°?]/g, "");
    return s.trim();
}

function showAnswer(force = false) {
  if(STATE.mode === 'type' && !force) {
    const input = document.getElementById('gameInput');
    const val = cleanText(input.value);
    const isEs = STATE.direction === 'es-en';
    const rawTarget = isEs ? STATE.currentCard.en : STATE.currentCard.es;
    const targets = rawTarget.split('/').map(t => cleanText(t));
    const cleanThe = (s) => s.replace(/^the\s+/, '');
    
    let isCorrect = false;
    if(isEs) {
        const valNoThe = cleanThe(val);
        isCorrect = targets.some(t => cleanThe(t) === valNoThe);
    } else {
        isCorrect = targets.includes(val);
    }
    
    if(isCorrect) {
      document.getElementById('gameFeedback').textContent = "‚úÖ Correct!";
      document.getElementById('gameFeedback').style.color = "#4ade80";
      markCard(true, true); 
      return; 
    } else {
      // HIDE INPUT to prevent copy paste
      document.getElementById('gameInputArea').style.display = 'none';

      document.getElementById('gameFeedback').textContent = `‚ùå Incorrect.`;
      document.getElementById('gameFeedback').style.color = "#f87171";
      triggerCardFeedback(false);
      markCard(false, false);
    }
  }

  document.getElementById('gameReveal').style.display = 'block';
  document.getElementById('gameControlsStart').style.display = 'none';
  document.getElementById('gameMiniControls').style.display = 'none';
  if(STATE.mode === 'reveal') {
    document.getElementById('gameControlsJudge').style.display = 'flex';
  } else {
    document.getElementById('gameControlsNext').style.display = 'flex';
  }
}

function triggerCardFeedback(isCorrect) {
    const card = document.getElementById('gameCard');
    const cls = isCorrect ? 'correct' : 'wrong';
    card.classList.remove('correct', 'wrong');
    void card.offsetWidth;
    card.classList.add(cls);
    setTimeout(() => { card.classList.remove(cls); }, 500);
}

function markCard(success, autoAdvance = true) {
  const uid = STATE.currentCard._uid;
  if(!STATE.progress[uid]) STATE.progress[uid] = { scoreEsEn: 0, scoreEnEs: 0, seen: 0 };
  
  // Ensure session data exists
  if(!STATE.sessionData[uid]) {
      STATE.sessionData[uid] = { count: 0, struggle: false, postCount: 0, correctInSession: false };
  }
  
  STATE.progress[uid].seen++;
  const isEs = STATE.direction === 'es-en';
  STATE.sessionData[uid].count++;
  if(STATE.sessionData[uid].struggle) STATE.sessionData[uid].postCount++;

  let currentScore = isEs ? STATE.progress[uid].scoreEsEn : STATE.progress[uid].scoreEnEs;

  if(success) {
      // MARK CORRECT
      STATE.sessionData[uid].correctInSession = true;

      STATE.streak++;
      triggerCardFeedback(true);
      if(STATE.sessionData[uid].count === 1) STATE.sessionStats.correctFirst++;
      
      currentScore = 4;
      
      if(STATE.streak > 0 && STATE.streak % 5 === 0) {
          const cardEl = document.getElementById('gameCard');
          cardEl.classList.add('streak-flash');
          setTimeout(() => cardEl.classList.remove('streak-flash'), 500);
      }
      
      if(STATE.isStruggleMode) {
        STATE.sessionStruggleIds = STATE.sessionStruggleIds.filter(id => id !== uid);
      }

      // STRUGGLE LOGIC: Remove only if correct on first try
      if(STATE.sessionData[uid].count === 1) {
          STATE.struggleList.delete(uid);
      }
      
      // Update Day Streak
      const today = new Date().toDateString();
      if(STATE.lastActiveDate !== today) {
          if(!STATE.lastActiveDate) {
              STATE.dayStreak = 1;
          } else {
              // Check if yesterday
              const yesterday = new Date();
              yesterday.setDate(yesterday.getDate() - 1);
              if(STATE.lastActiveDate === yesterday.toDateString()) {
                  STATE.dayStreak++;
              } else {
                  // Reset if gap > 1 day
                  STATE.dayStreak = 1;
              }
          }
          STATE.lastActiveDate = today;
          // Save immediately handled below
      }

  } else {
      // MARK INCORRECT
      // Note: If they previously got it right in this session (re-review?) we unmark it
      STATE.sessionData[uid].correctInSession = false;

      STATE.streak = 0;
      if(!autoAdvance) triggerCardFeedback(false); 
      
      currentScore = Math.max(0, currentScore - 1); 
      STATE.sessionData[uid].struggle = true;
      STATE.sessionData[uid].postCount = 0; 
      STATE.sessionStats.struggle++;
      if(!STATE.sessionStruggleIds.includes(uid)) STATE.sessionStruggleIds.push(uid);

      STATE.struggleList.add(uid);
  }

  if(isEs) STATE.progress[uid].scoreEsEn = currentScore;
  else STATE.progress[uid].scoreEnEs = currentScore;
  
  // Save Persistent Progress for Deck Resume
  // We only save if we are in a normal deck session (not filtered, not practice)
  if(!STATE.isStruggleMode && !STATE.customSessionList) {
      const isMix = !STATE.currentDeckId;
      const saveKey = isMix ? `mix_${STATE.selDiff}_${STATE.selLevel}` : STATE.currentDeckId;
      
      // Get all UIDs marked correct in this session
      const correctUids = Object.keys(STATE.sessionData).filter(k => STATE.sessionData[k].correctInSession);
      
      STATE.deckProgress[saveKey] = {
          lastPlayed: Date.now(),
          correctUids: correctUids
      };
      saveData();
  } else {
      // We still save general progress
      saveData();
  }

  updateStats();
  updatePersonalStatsUI();
  updateProgressBar(); // Update bar immediately
  
  if(autoAdvance) nextCard();
  else {
      const streakEl = document.getElementById('streakIndicator');
      if(STATE.streak >= 2) streakEl.textContent = `üî• ${STATE.streak}`;
      else streakEl.textContent = '';
  }
}

function toggleStar() {
    const uid = STATE.currentCard._uid;
    const btn = document.getElementById('btnStarCard');
    if(STATE.starred.has(uid)) {
        STATE.starred.delete(uid);
        btn.classList.remove('starred');
    } else {
        STATE.starred.add(uid);
        btn.classList.add('starred');
    }
    saveData();
    updateStats();
}

// --- GLOBAL EDIT MODAL ---
function openEditForCurrentCard() {
    openEditModal(STATE.currentCard._uid);
}

function openEditModal(uid) {
    editingCardUid = uid;
    let cardObj = null;
    const allDecks = STATE.activeDecks;
    const parts = uid.split(':');
    const deckId = parts[0];
    const esKey = parts.slice(1).join(':');
    const deck = allDecks.find(d => d.id === deckId);
    if(deck) {
        cardObj = deck.cards.find(c => c.es.replace(/\s/g,'') === esKey);
    }
    
    if(!cardObj) return alert("Card not found");

    document.getElementById('globalEditEs').value = cardObj.es;
    document.getElementById('globalEditEn').value = cardObj.en;
    document.getElementById('globalEditModal').style.display = 'flex';
}

function closeEditModal() {
    document.getElementById('globalEditModal').style.display = 'none';
    editingCardUid = null;
}

function saveGlobalEdit() {
    if(!editingCardUid) return;
    const es = document.getElementById('globalEditEs').value.trim();
    const en = document.getElementById('globalEditEn').value.trim();
    if(!es || !en) return alert("Fields cannot be empty");

    const parts = editingCardUid.split(':');
    const deckId = parts[0];
    const oldEsKey = parts.slice(1).join(':');
    
    const deck = STATE.activeDecks.find(d => d.id === deckId);
    if(deck) {
        const cardRef = deck.cards.find(c => c.es.replace(/\s/g,'') === oldEsKey);
        if(cardRef) {
            cardRef.es = es;
            cardRef.en = en;
        }
    }

    Object.values(STATE.customCards).forEach(list => {
        const match = list.find(c => c.es.replace(/\s/g,'') === oldEsKey && c._custom);
        if(match) {
            match.es = es;
            match.en = en;
        }
    });

    const newUid = `${deckId}:${es.replace(/\s/g,'')}`;
    if(newUid !== editingCardUid) {
        if(STATE.progress[editingCardUid]) {
            STATE.progress[newUid] = STATE.progress[editingCardUid];
            delete STATE.progress[editingCardUid];
        }
        if(STATE.starred.has(editingCardUid)) {
            STATE.starred.delete(editingCardUid);
            STATE.starred.add(newUid);
        }
        if(STATE.struggleList.has(editingCardUid)) {
            STATE.struggleList.delete(editingCardUid);
            STATE.struggleList.add(newUid);
        }
        if(STATE.blacklist.has(editingCardUid)) {
            STATE.blacklist.delete(editingCardUid);
            STATE.blacklist.add(newUid);
        }
    }

    saveData();
    closeEditModal();
    
    if(STATE.currentCard && (STATE.currentCard._uid === editingCardUid || STATE.currentCard._uid === newUid)) {
        STATE.currentCard.es = es;
        STATE.currentCard.en = en;
        STATE.currentCard._uid = newUid;
        renderGameCard();
    }
    
    if(document.getElementById('panel-words').classList.contains('active')) {
        renderWordList();
    }
}

function showDeckComplete() {
  document.getElementById('overlay').style.display = 'flex';
  document.getElementById('resCorrect').textContent = STATE.sessionStats.correctFirst;
  document.getElementById('resStruggle').textContent = STATE.sessionStats.struggle; 
  
  const btnStruggle = document.getElementById('btnPracticeStruggle');
  if(STATE.sessionStruggleIds.length > 0) {
    btnStruggle.style.display = 'inline-block';
    btnStruggle.textContent = `Practice Struggle Words (${STATE.sessionStruggleIds.length})`;
  } else {
    btnStruggle.style.display = 'none';
  }
  launchConfetti();
}

function closeOverlay() {
  document.getElementById('overlay').style.display = 'none';
  switchPanel('decks');
}

function launchConfetti() {
  const colors = ['#22c55e', '#38bdf8', '#facc15', '#f43f5e'];
  for(let i=0; i<50; i++) {
    const el = document.createElement('div');
    el.className = 'confetti';
    el.style.left = Math.random()*100 + 'vw';
    el.style.backgroundColor = colors[Math.floor(Math.random()*colors.length)];
    el.style.animationDuration = (Math.random()*2 + 2) + 's';
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 4000);
  }
}

function deleteCurrentCard() {
  if(!confirm("Permanently remove this card?")) return;
  const c = STATE.currentCard;
  if(c._custom) {
    const topicCards = STATE.customCards[STATE.activeDecks.find(d => d.id === c._realDeckId).topicId];
    if(topicCards) {
      const idx = topicCards.findIndex(x => x.es === c.es && x.en === c.en);
      if(idx > -1) topicCards.splice(idx, 1);
    }
  } 
  STATE.blacklist.add(c._uid);
  saveData();
  updateStats();
  nextCard();
}

function toggleGameSetting(type) {
    if(type === 'dir') {
        STATE.direction = (STATE.direction === 'es-en') ? 'en-es' : 'es-en';
        renderGameCard(); 
    } else if(type === 'mode') {
        STATE.mode = (STATE.mode === 'reveal') ? 'type' : 'reveal';
        document.getElementById('gameInputArea').style.display = STATE.mode === 'type' ? 'block' : 'none';
        if(STATE.mode === 'type') document.getElementById('gameInput').focus();
    }
    changeToggle(type, type === 'dir' ? STATE.direction : STATE.mode, false); 
    saveData();
    updateGameMiniSettings();
}

function updateGameMiniSettings() {
    const btnDir = document.getElementById('miniBtnDir');
    const btnMode = document.getElementById('miniBtnMode');
    btnDir.textContent = (STATE.direction === 'es-en') ? 'Swap: ES ‚û° EN' : 'Swap: EN ‚û° ES';
    btnMode.textContent = (STATE.mode === 'reveal') ? 'Mode: Reveal' : 'Mode: Type';
    btnDir.classList.remove('active');
    btnMode.classList.remove('active');
    if(STATE.direction === 'en-es') btnDir.classList.add('active');
    if(STATE.mode === 'type') btnMode.classList.add('active');
}


// --- WORDS MANAGER UI ---
function openSettings() {
    switchPanel('settings');
}

function openWordsManagerFromHeader(filter) {
  switchPanel('words');
  // Auto switch to Manage section
  document.getElementById('wordsLanding').style.display = 'none';
  document.getElementById('wordsAddSection').style.display = 'none';
  document.getElementById('wordsManageSection').style.display = 'block';
  
  STATE.activeFilter.status = filter;
  STATE.activeFilter.topic = 'all';
  resetAndRenderWords();
}

function toggleWordSection(section) {
    document.getElementById('wordsLanding').style.display = 'none';
    document.getElementById('wordsAddSection').style.display = 'none';
    document.getElementById('wordsManageSection').style.display = 'none';

    if(section === 'landing') {
        document.getElementById('wordsLanding').style.display = 'flex';
    } else if (section === 'add') {
        document.getElementById('wordsAddSection').style.display = 'block';
    } else if (section === 'manage') {
        document.getElementById('wordsManageSection').style.display = 'block';
        STATE.activeFilter.status = 'all'; 
        STATE.wordManagerLimit = 25;
        renderWordList();
    }
}

function toggleFilterMenu() {
    document.getElementById('filterDropdown').classList.toggle('show');
}
function applyFilter(type, val) {
    STATE.activeFilter[type] = val;
    STATE.wordManagerLimit = 25;
    document.getElementById('filterDropdown').classList.remove('show');
    
    // Update active class in dropdown
    const headers = document.querySelectorAll('.fd-item');
    headers.forEach(h => {
        if(h.textContent.toLowerCase().includes(val)) h.classList.add('active');
        else h.classList.remove('active'); 
    });
    
    renderWordList();
}
function toggleSort() {
    STATE.sortAsc = !STATE.sortAsc;
    resetAndRenderWords();
}

function resetAndRenderWords() {
    STATE.wordManagerLimit = 25;
    renderWordList();
}

function showMoreWords() {
    STATE.wordManagerLimit += 25;
    renderWordList();
}

function playFilteredList() {
    const list = getFilteredWordsList();
    if(list.length === 0) return alert("No words to play");
    const uids = list.map(c => c._uid);
    startFilteredSession(uids);
}

function getFilteredWordsList() {
    const fStatus = STATE.activeFilter.status;
    const fTopic = STATE.activeFilter.topic;
    const fSearch = document.getElementById('searchWords').value.toLowerCase().trim();

    const allCardsMap = new Map();
    STATE.activeDecks.forEach(d => {
        d.cards.forEach(c => {
           const uid = getCardId(d.id, c);
           if(STATE.blacklist.has(uid)) return;
           const p = STATE.progress[uid] || { scoreEsEn: 0, scoreEnEs: 0, seen: 0 };
           const maxScore = Math.max(p.scoreEsEn || 0, p.scoreEnEs || 0); 

           if(fStatus === 'known' && maxScore < 4) return;
           if(fStatus === 'struggle' && !STATE.struggleList.has(uid)) return;
           if(fStatus === 'starred' && !STATE.starred.has(uid)) return;

           if(fTopic !== 'all' && d.topicId !== fTopic) return;
           if(fSearch && !c.es.toLowerCase().includes(fSearch) && !c.en.toLowerCase().includes(fSearch)) return;

           allCardsMap.set(uid, { ...c, _deckName: d.name, _score: maxScore, _uid: uid });
        });
    });
    
    let list = Array.from(allCardsMap.values());
    list.sort((a,b) => STATE.sortAsc ? a.es.localeCompare(b.es) : b.es.localeCompare(a.es));
    return list;
}

function renderWordList() {
  const container = document.getElementById('wordListContainer');
  const btnPlay = document.getElementById('btnPlayFilter');
  const btnMore = document.getElementById('btnShowMoreWords');
  
  const list = getFilteredWordsList();
  
  // Show Play Button only if filtered
  if(STATE.activeFilter.status !== 'all' || STATE.activeFilter.topic !== 'all') {
      btnPlay.style.display = 'block';
      btnPlay.textContent = `‚ñ∂ Play ${list.length} Words`;
  } else {
      btnPlay.style.display = 'none';
  }

  container.innerHTML = '';
  if(list.length === 0) {
    container.innerHTML = '<div style="padding:20px; text-align:center; color:var(--text-muted)">No words match filter.</div>';
    btnMore.style.display = 'none';
    return;
  }

  const renderLimit = Math.min(list.length, STATE.wordManagerLimit);
  
  for(let i=0; i<renderLimit; i++) {
    const c = list[i];
    const scoreClass = c._score >= 4 ? 'score-4' : (c._score === 3 ? 'score-3' : (c._score > 0 ? 'score-1' : 'score-0'));
    let bgClass = '';
    if(c._custom) bgClass = 'bg-custom';
    else if(STATE.struggleList.has(c._uid)) bgClass = 'bg-diff-advanced'; // Visual hint for struggle
    else if(STATE.starred.has(c._uid)) bgClass = 'bg-diff-proficient'; 

    // Safe escape for TTS
    const cleanEs = c.es.replace(/'/g, "\\'");

    const el = document.createElement('div');
    el.className = `word-row ${bgClass}`;
    el.innerHTML = `
      <div class="word-info">
        <div class="word-main">
          <span class="word-score ${scoreClass}"></span>
          <button class="btn-tts" onclick="speakSpanish('${cleanEs}')" title="Listen">üîä</button>
          ${c.es} 
          <span style="font-weight:400; color:var(--text-muted)">‚Äî ${c.en}</span>
        </div>
        <div class="word-sub">
          ${c._deckName}
          ${c._custom ? '<span class="word-tag">Custom</span>' : ''}
          ${STATE.starred.has(c._uid) ? '<span class="word-tag" style="color:#facc15">‚òÖ</span>' : ''}
          ${STATE.struggleList.has(c._uid) ? '<span class="word-tag" style="color:#fca5a5">Struggle</span>' : ''}
        </div>
      </div>
      <div style="display:flex; gap:4px">
        <button class="btn-icon edit" onclick="openEditModal('${c._uid}')">‚úèÔ∏è</button>
        <button class="btn-icon del" onclick="deleteWordByUid('${c._uid}')">üóë</button>
      </div>
    `;
    container.appendChild(el);
  }

  if(list.length > STATE.wordManagerLimit) {
      btnMore.style.display = 'block';
      btnMore.textContent = `Show More (${list.length - STATE.wordManagerLimit} remaining)`;
  } else {
      btnMore.style.display = 'none';
  }
}

function deleteWordByUid(uid) {
  if(!confirm("Permanently delete word?")) return;
  STATE.blacklist.add(uid);
  saveData();
  renderWordList(); 
  updateStats();
}

function populateTopicFilter() {
  const sel = document.getElementById('filterTopicContainer');
  const addSel = document.getElementById('addTopicSelect');
  sel.innerHTML = '';
  addSel.innerHTML = '';
  
  if(STATE.decksRaw.topics) {
    STATE.decksRaw.topics.forEach(t => {
      // Filter Menu Item
      const item = document.createElement('div');
      item.className = 'fd-item';
      item.textContent = t.label;
      item.onclick = () => applyFilter('topic', t.id);
      sel.appendChild(item);

      // Add Dropdown
      const opt2 = document.createElement('option');
      opt2.value = t.id;
      opt2.textContent = t.label;
      addSel.appendChild(opt2);
    });
  }
}

function toggleAddEx() {
  const div = document.getElementById('divAddEx');
  const btn = document.getElementById('btnToggleEx');
  if(div.style.display === 'none') {
    div.style.display = 'block';
    btn.textContent = '‚ûñ Hide Examples';
  } else {
    div.style.display = 'none';
    btn.textContent = '‚ûï Add Examples (Optional)';
  }
}

function onAddSubmit() {
  const es = document.getElementById('addEs').value.trim();
  const en = document.getElementById('addEn').value.trim();
  const topicId = document.getElementById('addTopicSelect').value;
  const exEs = document.getElementById('addExEs').value.trim();
  const exEn = document.getElementById('addExEn').value.trim();
  
  if(!es || !en || !topicId) {
    document.getElementById('addMsg').textContent = "Please fill required fields.";
    document.getElementById('addMsg').style.color = "#f87171";
    return;
  }
  
  const newCard = { es, en, exampleEs: exEs, exampleEn: exEn, _custom: true };
  if(!STATE.customCards[topicId]) STATE.customCards[topicId] = [];
  STATE.customCards[topicId].push(newCard);
  
  STATE.activeDecks.forEach(d => {
    if(d.topicId === topicId) { d.cards.push(newCard); }
  });
  saveData();
  updateStats();
  
  const topicLabel = STATE.decksRaw.topics.find(t=>t.id===topicId)?.label || "Topic";
  document.getElementById('addMsg').textContent = `Added to ${topicLabel} decks!`;
  document.getElementById('addMsg').style.color = "#4ade80";
  
  document.getElementById('addEs').value = '';
  document.getElementById('addEn').value = '';
  document.getElementById('addExEs').value = '';
  document.getElementById('addExEn').value = '';
  document.getElementById('addEs').focus();
  setTimeout(() => document.getElementById('addMsg').textContent = '', 2000);
}

// --- UTILS ---
function switchPanel(panelId) {
  document.querySelectorAll('.panel').forEach(el => el.classList.remove('active'));
  document.getElementById('panel-'+panelId).classList.add('active');
  
  if (panelId === 'ranks') {
      renderRanksPanel();
      // Keep 'decks' tab active visually
      panelId = 'decks';
  }

  document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
  const navBtn = document.querySelector(`.nav-tab[data-panel="${panelId}"]`);
  if(navBtn) navBtn.classList.add('active');
  
  if(panelId === 'decks') renderDecks();
  // Words panel reset handled in specific functions
}

function changeToggle(group, val, shouldSave=true) {
  document.querySelectorAll(`.toggle-btn[data-group="${group}"]`).forEach(btn => {
    if(btn.dataset.val === val) btn.classList.add('active');
    else btn.classList.remove('active');
  });
  if(group === 'dir') STATE.direction = val;
  if(group === 'mode') STATE.mode = val;
  
  updateGameMiniSettings(); 
  if(shouldSave) saveData();
}

function toggleSetting(key) {
  STATE[key] = !STATE[key];
  saveData();
  updateCheckUI(key, STATE[key]);
  renderDecks();
}

function updateCheckUI(key, val) {
  const el = document.getElementById('btnToggle' + key.charAt(0).toUpperCase() + key.slice(1));
  if(!el) return;
  if(val) {
    el.classList.add('checked');
    el.querySelector('.status-icon').textContent = '‚úì';
  } else {
    el.classList.remove('checked');
    el.querySelector('.status-icon').textContent = '‚óã';
  }
}

function updateStats() {
  const known = getKnownWordCount();
  
  document.getElementById('statKnown').textContent = known;
  document.getElementById('statStruggle').textContent = STATE.struggleList.size;
  document.getElementById('statStarred').textContent = STATE.starred.size;
  updatePersonalStatsUI();
}

function getCardId(deckId, card) {
  return `${deckId}:${card.es.replace(/\s/g,'')}`;
}

function resetAllData() {
  if(confirm("Reset ALL data? Progress, custom cards, and settings will be lost.")) {
    localStorage.clear();
    location.reload();
  }
}

// --- BINDINGS ---
function bindEvents() {
  document.querySelectorAll('.nav-tab').forEach(btn => {
    btn.onclick = () => switchPanel(btn.dataset.panel);
  });
  document.querySelectorAll('.toggle-btn').forEach(btn => {
    btn.onclick = () => changeToggle(btn.dataset.group, btn.dataset.val);
  });
  
  document.getElementById('btnShowAnswer').onclick = () => showAnswer();
  document.getElementById('btnEasy').onclick = () => markCard(true);
  document.getElementById('btnHard').onclick = () => markCard(false);
  document.getElementById('btnNextCard').onclick = () => nextCard();
  document.getElementById('btnDeleteCard').onclick = deleteCurrentCard;
  
  document.getElementById('gameInput').onkeydown = (e) => {
    if(e.key === 'Enter') showAnswer();
  };
  
  document.getElementById('btnAddSubmit').onclick = onAddSubmit;
  document.getElementById('btnResetData').onclick = resetAllData;
  
  // Close filter dropdown if clicking outside
  document.addEventListener('click', (e) => {
      const toolBtn = document.querySelector('.tool-btn[title="Filter"]');
      const drop = document.getElementById('filterDropdown');
      if(!toolBtn.contains(e.target) && !drop.contains(e.target)) {
          drop.classList.remove('show');
      }
  });
}

// Start
init();

</script>
</body>
</html>

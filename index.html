<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spanish Flashcards ‚Äì Mastery Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <meta name="theme-color" content="#0f172a" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Spanish Cards" />

  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
  />

  <style>
    :root {
      --bg-gradient: radial-gradient(circle at top left, #1e293b, #0f172a 60%, #020617);
      --card-bg: rgba(30, 41, 59, 0.7);
      --card-border: 1px solid rgba(148, 163, 184, 0.15);
      --accent: #22c55e;
      --accent-hover: #16a34a;
      --accent-soft: rgba(34, 197, 94, 0.15);
      --gold: #eab308;
      --gold-soft: rgba(234, 179, 8, 0.15);
      --text-main: #f1f5f9;
      --text-muted: #94a3b8;
      --danger: #ef4444;
      --danger-soft: rgba(239, 68, 68, 0.15);
      --radius-lg: 24px;
      --radius-md: 16px;
      --radius-sm: 12px;
      --shadow-soft: 0 10px 40px -10px rgba(0, 0, 0, 0.5);
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
      margin: 0;
      font-family: "Inter", system-ui, sans-serif;
      background: var(--bg-gradient);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 10px; 
    }

    /* --- App Container --- */
    .app {
      width: 100%;
      max-width: 800px;
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: var(--card-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-soft);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 85vh;
    }

    /* --- Header --- */
    .app-header {
      padding: 20px;
      border-bottom: var(--card-border);
      background: rgba(15, 23, 42, 0.8);
    }

    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 16px;
    }

    .logo-block h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
      letter-spacing: -0.02em;
    }

    .logo-pill {
      font-size: 10px;
      text-transform: uppercase;
      background: var(--accent-soft);
      border-radius: 99px;
      padding: 3px 8px;
      color: #86efac;
      letter-spacing: 0.05em;
      border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .deck-description {
      margin: 4px 0 0 0;
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.4;
    }

    /* Stats Pills */
    .stats-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .stat-pill {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 99px;
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-muted);
      display: inline-flex;
      gap: 4px;
      cursor: pointer;
      transition: 0.2s;
    }
    .stat-pill:hover { background: rgba(30, 41, 59, 0.9); border-color: var(--text-muted); }
    .stat-pill strong { color: var(--text-main); font-weight: 600; }
    .stat-pill.accent { border-color: rgba(34, 197, 94, 0.4); color: #bbf7d0; background: rgba(34, 197, 94, 0.1); }
    .stat-pill.danger { border-color: rgba(239, 68, 68, 0.4); color: #fecaca; background: rgba(239, 68, 68, 0.1); }

    /* --- Navigation Tabs --- */
    .nav-tabs {
      display: flex;
      gap: 8px;
      background: rgba(15, 23, 42, 0.6);
      padding: 4px;
      border-radius: 99px;
      border: var(--card-border);
      overflow-x: auto;
    }

    .nav-tab {
      flex: 1;
      border: none;
      background: transparent;
      color: var(--text-muted);
      padding: 8px 12px;
      border-radius: 99px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      white-space: nowrap;
    }
    .nav-tab:hover { color: var(--text-main); background: rgba(255,255,255,0.03); }
    .nav-tab.active {
      background: var(--accent);
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 2px 10px rgba(34, 197, 94, 0.3);
    }

    /* --- Panels --- */
    .panel-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow-y: auto;
      max-height: 75vh;
    }
    .panel { display: none; padding: 20px; animation: fadeIn 0.2s ease; }
    .panel.active { display: block; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

    /* Decks Grid */
    .deck-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; }
    .deck-card {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.1);
      border-radius: var(--radius-sm);
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      gap: 4px;
      position: relative;
    }
    .deck-card:hover { background: rgba(30, 41, 59, 0.9); border-color: rgba(148, 163, 184, 0.3); transform: translateY(-2px); }
    .deck-card.active { border-color: var(--accent); background: rgba(34, 197, 94, 0.05); }
    
    /* Green Mastery (One Direction) */
    .deck-card.mastered-green {
      border-color: var(--accent);
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.6), rgba(34, 197, 94, 0.1));
    }
    .deck-card.mastered-green::after {
      content: '‚úî'; position: absolute; top: 10px; right: 10px; color: var(--accent); font-size: 14px;
    }

    /* Gold Mastery (Both Directions) */
    .deck-card.mastered-gold {
      border-color: var(--gold);
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.6), rgba(234, 179, 8, 0.15));
      box-shadow: 0 0 15px rgba(234, 179, 8, 0.1);
    }
    .deck-card.mastered-gold::after {
      content: '‚òÖ'; position: absolute; top: 10px; right: 10px; color: var(--gold); font-size: 16px;
    }

    /* Specific Layout for Difficulty Cards (UPDATED) */
    .deck-card.diff-card {
        flex-direction: row; 
        align-items: center; 
        gap: 16px; 
        padding: 16px 20px; /* Nicer padding */
    }
    .diff-emoji { 
        font-size: 28px; /* Smaller emoji */
        line-height: 1; 
        min-width: 32px; /* Fixed width to prevent misalignment */
        text-align: center;
    }
    .diff-text-col { 
        display: flex; 
        flex-direction: column; 
        gap: 2px; 
        flex: 1; /* Takes remaining space */
        min-width: 0; /* Prevents text overflow breaking layout */
    }
    .diff-title { font-weight: 700; font-size: 16px; color: var(--text-main); }
    .diff-sub { font-size: 12px; color: var(--text-muted); }

    .deck-title { font-weight: 600; font-size: 14px; }
    .deck-count { font-size: 12px; color: var(--text-muted); }
    .deck-section-title { margin: 0 0 15px 0; font-size: 18px; font-weight: 600; color: #fff; }

    /* Breadcrumbs */
    .breadcrumbs { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; }
    .back-btn {
      background: transparent; border: 1px solid rgba(148, 163, 184, 0.3);
      color: var(--text-muted); padding: 4px 10px; border-radius: 99px;
      font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 4px;
    }
    .back-btn:hover { border-color: var(--text-muted); color: var(--text-main); }

    /* Settings */
    .setting-group { margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid rgba(148,163,184,0.1); }
    .setting-group:last-child { border-bottom: none; }
    .setting-header { font-size: 13px; color: var(--text-main); margin-bottom: 8px; font-weight: 500; }
    .toggle-row { display: flex; gap: 4px; background: rgba(15,23,42,0.4); padding: 3px; border-radius: 99px; width: fit-content; border: 1px solid rgba(148,163,184,0.1); flex-wrap: wrap; }
    .toggle-btn {
      border: none; background: transparent; color: var(--text-muted);
      padding: 6px 12px; border-radius: 99px; font-size: 12px; cursor: pointer; transition: 0.2s;
    }
    .toggle-btn.active { background: var(--accent); color: #022c22; font-weight: 600; }
    
    .setting-check-btn {
      display: flex; align-items: center; justify-content: space-between;
      width: 100%; padding: 10px; border-radius: var(--radius-sm);
      background: rgba(30, 41, 59, 0.4); border: 1px solid rgba(148,163,184,0.1);
      cursor: pointer; margin-bottom: 8px; font-size: 13px; color: var(--text-muted);
    }
    .setting-check-btn.checked { background: rgba(34, 197, 94, 0.1); border-color: rgba(34, 197, 94, 0.3); color: #bbf7d0; }
    
    .setting-nav-btn {
      width: 100%; display: flex; align-items: center; justify-content: space-between;
      padding: 14px; background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(148,163,184,0.2);
      border-radius: var(--radius-sm); color: var(--text-main); font-size: 14px; font-weight: 500;
      cursor: pointer; transition: 0.2s;
    }
    .setting-nav-btn:hover { background: rgba(30, 41, 59, 0.8); border-color: var(--accent); }

    /* Add Card Form */
    .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .form-group { display: flex; flex-direction: column; gap: 6px; }
    .form-group.full { grid-column: span 2; }
    label { font-size: 12px; color: var(--text-muted); font-weight: 500; }
    input, textarea, select {
      background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-main); padding: 12px; border-radius: var(--radius-sm);
      font-family: inherit; font-size: 15px; outline: none; transition: 0.2s;
      width: 100%;
    }
    input:focus, textarea:focus, select:focus { border-color: var(--accent); background: rgba(15, 23, 42, 0.8); }
    .btn-submit {
      width: 100%; background: var(--accent); color: #022c22; border: none;
      padding: 14px; border-radius: var(--radius-sm); font-weight: 600; font-size: 15px;
      cursor: pointer; margin-top: 12px;
    }
    .btn-submit:hover { background: var(--accent-hover); }
    .toggle-ex-btn {
      background: transparent; border: 1px dashed rgba(148,163,184,0.3); color: var(--text-muted);
      width: 100%; padding: 8px; border-radius: var(--radius-sm); cursor: pointer; font-size: 12px;
    }
    .toggle-ex-btn:hover { border-color: var(--accent); color: var(--accent); }

    /* Words Manager */
    .word-manager-container { max-height: 500px; overflow-y: auto; margin-top: 10px; }
    .filter-bar { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
    .filter-input { flex: 1; min-width: 120px; padding: 8px; font-size: 13px; }
    .word-list { display: flex; flex-direction: column; gap: 6px; }
    .word-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px; background: rgba(30,41,59,0.5); border-radius: var(--radius-sm);
      border: 1px solid rgba(148,163,184,0.1);
    }
    /* Difficulty Colors */
    .word-row.bg-diff-beginner { background: rgba(34, 197, 94, 0.08); border-color: rgba(34, 197, 94, 0.1); }
    .word-row.bg-diff-intermediate { background: rgba(56, 189, 248, 0.08); border-color: rgba(56, 189, 248, 0.1); }
    .word-row.bg-diff-advanced { background: rgba(168, 85, 247, 0.08); border-color: rgba(168, 85, 247, 0.1); }
    .word-row.bg-custom { background: rgba(234, 179, 8, 0.08); border-color: rgba(234, 179, 8, 0.1); }

    .word-info { flex: 1; }
    .word-main { font-weight: 600; font-size: 14px; color: var(--text-main); }
    .word-sub { font-size: 11px; color: var(--text-muted); }
    .word-tag { font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: 6px; background: rgba(0,0,0,0.3); color: #94a3b8; }
    .word-score { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 8px; }
    .score-0 { background: #334155; }
    .score-1 { background: #fca5a5; }
    .score-3 { background: #bae6fd; }
    .score-4 { background: #4ade80; }
    
    .btn-icon { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 6px; font-size: 14px; }
    .btn-icon:hover { color: var(--danger); }

    /* Game Card */
    .game-area {
      flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; min-height: 400px;
    }
    .flashcard {
      width: 100%; max-width: 500px; min-height: 280px;
      background: var(--bg-gradient);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: var(--radius-lg);
      padding: 30px;
      display: flex; flex-direction: column; justify-content: space-between;
      position: relative; box-shadow: 0 20px 50px -12px rgba(0,0,0,0.5);
    }
    .card-meta { display: flex; justify-content: space-between; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 20px; }
    .card-main { text-align: center; flex: 1; display: flex; flex-direction: column; justify-content: center; }
    .label-lang { font-size: 11px; color: var(--text-muted); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
    .word-text { font-size: 36px; font-weight: 700; color: var(--text-main); margin-bottom: 20px; line-height: 1.2; word-break: break-word; }
    .reveal-section { border-top: 1px dashed rgba(148,163,184,0.2); padding-top: 20px; margin-top: 10px; animation: fadeIn 0.3s ease; }
    .reveal-text { font-size: 24px; font-weight: 500; color: #bae6fd; margin-bottom: 8px; }
    .examples { font-size: 14px; color: var(--text-muted); font-style: italic; line-height: 1.5; }

    /* Game Actions */
    .action-row { display: flex; gap: 8px; width: 100%; max-width: 500px; }
    .btn-action {
      flex: 1; border: 1px solid rgba(148,163,184,0.2); background: rgba(30,41,59,0.5);
      color: var(--text-main); padding: 12px; border-radius: 99px; font-size: 14px;
      cursor: pointer; transition: 0.2s; font-weight: 500;
    }
    .btn-action:hover { background: rgba(30,41,59,0.8); transform: translateY(-1px); }
    .btn-action.primary { background: var(--text-main); color: #020617; font-weight: 600; border: none; }
    .btn-action.primary:hover { background: #e2e8f0; }
    .btn-action.success { background: var(--accent); color: #064e3b; border: none; font-weight: 600; }
    .btn-action.danger { background: rgba(239,68,68,0.2); color: #fca5a5; border-color: rgba(239,68,68,0.5); }
    .btn-action.ghost { background: transparent; border-color: transparent; color: var(--text-muted); font-size: 12px; flex: 0; white-space: nowrap; }
    .btn-action.ghost:hover { color: var(--danger); }

    .input-answer {
      width: 100%; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 14px; border-radius: 99px; color: white; font-size: 16px; text-align: center;
      margin-bottom: 10px; outline: none;
    }
    .input-answer:focus { border-color: var(--accent); }

    /* Mini In-Game Settings (Now Below Buttons) */
    .mini-controls {
        display: flex; gap: 10px; justify-content: center; width: 100%; margin-top: 10px;
    }
    .mini-btn {
        background: transparent; border: 1px solid rgba(148,163,184,0.15);
        color: var(--text-muted); font-size: 11px; padding: 6px 14px;
        border-radius: 99px; cursor: pointer; transition: 0.2s;
        text-transform: uppercase; letter-spacing: 0.5px;
    }
    .mini-btn:hover { border-color: var(--text-muted); color: var(--text-main); }
    .mini-btn.active { background: rgba(34,197,94,0.1); color: #86efac; border-color: rgba(34,197,94,0.3); }

    /* Overlay */
    .overlay { position: fixed; inset: 0; background: rgba(2, 6, 23, 0.9); z-index: 100; display: none; align-items: center; justify-content: center; backdrop-filter: blur(4px); }
    .overlay-content { background: #1e293b; padding: 30px; border-radius: var(--radius-lg); text-align: center; max-width: 90%; width: 400px; border: 1px solid rgba(148,163,184,0.2); }
    .confetti-container { position: fixed; inset: 0; pointer-events: none; z-index: 101; overflow: hidden; }
    .confetti { position: absolute; width: 8px; height: 14px; animation: fall 3s linear forwards; }
    @keyframes fall { to { transform: translateY(110vh) rotate(360deg); opacity: 0; } }

    @media (max-width: 600px) {
      .app { min-height: 100vh; border-radius: 0; border: none; }
      .flashcard { min-height: 240px; padding: 20px; }
      .word-text { font-size: 28px; }
      .form-grid { grid-template-columns: 1fr; }
      .form-group.full { grid-column: span 1; }
      .nav-tabs { justify-content: flex-start; }
    }
  </style>
</head>
<body>

<div class="app">
  <header class="app-header">
    <div class="header-top">
      <div class="logo-block">
        <h1>Spanish Flashcards <span class="logo-pill">PRO</span></h1>
        <p class="deck-description" id="headerDesc">Select a difficulty to begin.</p>
      </div>
      <div class="stats-row">
        <div class="stat-pill accent" onclick="openWordsManagerFromHeader('known')">Known: <strong id="statKnown">0</strong></div>
        <div class="stat-pill danger" onclick="openWordsManagerFromHeader('learning')">Learning: <strong id="statLearning">0</strong></div>
        <div class="stat-pill" onclick="openWordsManagerFromHeader('all')">Total: <strong id="statTotal">0</strong></div>
      </div>
    </div>

    <div class="nav-tabs">
      <button class="nav-tab active" data-panel="decks">üìö Decks</button>
      <button class="nav-tab" data-panel="game">üéÆ Play</button>
      <button class="nav-tab" data-panel="add">‚ûï Add</button>
      <button class="nav-tab" data-panel="settings">‚öôÔ∏è Settings</button>
    </div>
  </header>

  <div class="panel-container">
    
    <div id="panel-decks" class="panel active">
      <h2 class="deck-section-title">Let's start learning!</h2>
      <div id="deckBreadcrumbs" class="breadcrumbs"></div>
      <div id="deckGrid" class="deck-grid">
        <div style="padding:20px; color:var(--text-muted)">Loading...</div>
      </div>
    </div>

    <div id="panel-game" class="panel">
      <div class="game-area">
        <div class="flashcard" id="gameCard">
          <div class="card-meta">
            <span id="gameDeckName">All Decks</span>
            <span id="gameStrength">New Word</span>
          </div>
          
          <div class="card-main">
            <div class="label-lang" id="gameFrontLabel">Spanish</div>
            <div class="word-text" id="gameFrontText">Pick a deck to start</div>
            
            <div id="gameInputArea" style="display:none; width:100%;">
              <input type="text" class="input-answer" id="gameInput" placeholder="Type answer..." autocomplete="off" autocapitalize="off">
              <div id="gameFeedback" style="font-size:13px; min-height:20px;"></div>
            </div>

            <div class="reveal-section" id="gameReveal" style="display:none">
              <div class="label-lang" id="gameBackLabel">English</div>
              <div class="reveal-text" id="gameBackText">...</div>
              <div class="examples" id="gameExamples"></div>
            </div>
          </div>
        </div>
        
        <div class="action-row" id="gameControlsStart">
          <button class="btn-action ghost" id="btnDeleteCard" title="Permanently Delete">üóë Remove</button>
          <button class="btn-action primary" id="btnShowAnswer">Show Answer</button>
        </div>

        <div class="action-row" id="gameControlsJudge" style="display:none">
          <button class="btn-action danger" id="btnHard">Still Learning</button>
          <button class="btn-action success" id="btnEasy">I Knew It</button>
        </div>
        
        <div class="action-row" id="gameControlsNext" style="display:none">
           <button class="btn-action primary" id="btnNextCard">Next Card ‚û°</button>
        </div>

        <div class="mini-controls" id="gameMiniControls">
            <button class="mini-btn" id="miniBtnDir" onclick="toggleGameSetting('dir')">Swap: ES ‚û° EN</button>
            <button class="mini-btn" id="miniBtnMode" onclick="toggleGameSetting('mode')">Mode: Reveal</button>
        </div>
      </div>
    </div>

    <div id="panel-add" class="panel">
      <div class="form-grid">
        <div class="form-group">
          <label>Spanish Word</label>
          <input type="text" id="addEs" placeholder="e.g. la mesa" autocapitalize="off" autocomplete="off">
        </div>
        <div class="form-group">
          <label>English Translation</label>
          <input type="text" id="addEn" placeholder="e.g. the table" autocapitalize="off" autocomplete="off">
        </div>
        <div class="form-group full">
          <label>Category (Topic)</label>
          <select id="addTopicSelect"></select>
          <div style="font-size:11px; color:var(--text-muted); margin-top:4px;">
            Added words appear in <strong>Mix</strong> decks and specific <strong>Topic</strong> decks across all levels.
          </div>
        </div>
        
        <div class="form-group full">
          <button type="button" class="toggle-ex-btn" id="btnToggleEx" onclick="toggleAddEx()">‚ûï Add Examples (Optional)</button>
        </div>

        <div class="form-group full" id="divAddEx" style="display:none">
          <textarea id="addExEs" placeholder="Spanish example sentence..." rows="2" autocapitalize="off"></textarea>
          <textarea id="addExEn" placeholder="English translation..." rows="2" autocapitalize="off" style="margin-top:8px"></textarea>
        </div>

        <div class="form-group full">
          <button class="btn-submit" id="btnAddSubmit">Save Card</button>
          <div id="addMsg" style="text-align:center; font-size:12px; margin-top:8px; min-height:16px;"></div>
        </div>
      </div>
    </div>

    <div id="panel-settings" class="panel">
      
      <div id="settings-words-manager" style="display:none">
        <div class="breadcrumbs" style="margin-bottom:15px">
           <button class="back-btn" onclick="closeWordsManager()">‚Äπ Back to Settings</button>
        </div>
        <div class="filter-bar">
         <select id="filterDifficulty" class="input-answer filter-input" onchange="renderWordList()">
           <option value="all">All Difficulties</option>
           </select>
         <select id="filterStatus" class="input-answer filter-input" onchange="renderWordList()">
           <option value="all">All Status</option>
           <option value="known">Known / Mastered</option>
           <option value="learning">Still Learning</option>
         </select>
         <select id="filterTopic" class="input-answer filter-input" onchange="renderWordList()">
           <option value="all">All Categories</option>
         </select>
         <select id="filterSort" class="input-answer filter-input" onchange="renderWordList()">
            <option value="diff">Sort: Difficulty</option>
            <option value="az">Sort: A-Z (ES)</option>
         </select>
       </div>
       <div id="wordListContainer" class="word-list word-manager-container">
          </div>
      </div>

      <div id="settings-main">
        <div class="setting-group">
          <div class="setting-header">Content Manager</div>
          <button class="setting-nav-btn" onclick="openWordsManager()">
              <span>üóÇ Manage All Words</span>
              <span style="opacity:0.5; font-size:18px">‚Ä∫</span>
          </button>
        </div>

        <div class="setting-group">
          <div class="setting-header">Custom Content</div>
          <div class="setting-check-btn" id="btnToggleIncludeCustom" onclick="toggleSetting('includeCustom')">
              <span>Include my added words in decks</span>
              <span class="status-icon">‚úì</span>
          </div>
          <div class="setting-check-btn" id="btnToggleOnlyCustom" onclick="toggleSetting('onlyCustom')">
              <span>Play ONLY my added words</span>
              <span class="status-icon">‚óã</span>
          </div>
        </div>

        <div class="setting-group">
          <div class="setting-header">Practice Direction</div>
          <div class="toggle-row">
            <button class="toggle-btn active" data-group="dir" data-val="es-en">Spanish ‚Üí English</button>
            <button class="toggle-btn" data-group="dir" data-val="en-es">English ‚Üí Spanish</button>
          </div>
        </div>

        <div class="setting-group">
          <div class="setting-header">Answer Mode</div>
          <div class="toggle-row">
            <button class="toggle-btn active" data-group="mode" data-val="reveal">Self Check</button>
            <button class="toggle-btn" data-group="mode" data-val="type">Type Answer</button>
          </div>
        </div>

        <div class="setting-group">
          <div class="setting-header">Data</div>
          <button class="btn-action danger" id="btnResetData" style="width:100%">Reset All Progress</button>
        </div>
      </div>

    </div>

  </div>

  <div class="overlay" id="overlay">
    <div class="overlay-content">
      <h2 style="margin-top:0">üéâ Deck Complete!</h2>
      
      <div style="display:flex; justify-content:center; gap:10px; margin-bottom:20px;">
        <div class="stat-pill accent">1st Time Correct: <strong id="resCorrect">0</strong></div>
        <div class="stat-pill danger">Struggled: <strong id="resStruggle">0</strong></div>
      </div>
      
      <button class="btn-action primary" onclick="closeOverlay()">Back to Decks</button>
      <button class="btn-action danger" id="btnPracticeStruggle" style="margin-top:10px" onclick="startPracticeStruggle()">Practice Struggle Words</button>
    </div>
  </div>

</div>

<script>
/**
 * APP LOGIC
 */
const STATE = {
  decksRaw: [], // Loaded from JSON
  activeDecks: [], // Flattened list
  customCards: {}, // { topicId: [cards] } 
  progress: {}, // { cardId: { scoreEsEn, scoreEnEs, seen } }
  blacklist: new Set(), // Deleted card IDs
  
  // Session State
  sessionData: {}, // { uid: { count: 0, struggle: false, postCount: 0 } }
  sessionStats: { correctFirst: 0, struggle: 0 },
  struggleList: [], 
  lastCardUid: null,
  revealTime: 0,
  
  // Navigation
  view: 'root', 
  selDiff: null,
  selLevel: null,
  
  // Game Config
  currentDeckId: null,
  currentCard: null,
  isStruggleMode: false,
  
  // Settings
  direction: 'es-en',
  mode: 'reveal',
  includeCustom: true,
  onlyCustom: false
};

// --- INIT ---
async function init() {
  loadLocalData();
  await loadRemoteData();
  bindEvents();
  renderDecks();
  updateStats();
  populateAddDropdown();
  updateGameMiniSettings();
}

// --- DATA HANDLING ---
async function loadRemoteData() {
  try {
    const res = await fetch('decks.json');
    if(!res.ok) throw new Error("404");
    const json = await res.json();
    STATE.decksRaw = json;
    STATE.activeDecks = json.decks.map(d => ({ ...d, cards: [...d.cards] }));
    injectCustomCards();
    renderDecks();
  } catch (e) {
    document.getElementById('deckGrid').innerHTML = `<div style="padding:20px; color:#fca5a5">Error loading decks.json. Ensure file exists and is accessible.</div>`;
  }
}

function loadLocalData() {
  const custom = localStorage.getItem('sf_custom');
  if(custom) STATE.customCards = JSON.parse(custom);

  const prog = localStorage.getItem('sf_progress');
  if(prog) {
    const rawProg = JSON.parse(prog);
    // Migration: If score is a number, assume it was es_en
    STATE.progress = {};
    Object.keys(rawProg).forEach(uid => {
        const item = rawProg[uid];
        if(typeof item.score === 'number') {
            STATE.progress[uid] = { 
                scoreEsEn: item.score, 
                scoreEnEs: 0, 
                seen: item.seen || 0 
            };
        } else {
            STATE.progress[uid] = item;
        }
    });
  }

  const black = localStorage.getItem('sf_blacklist');
  if(black) STATE.blacklist = new Set(JSON.parse(black));
  
  // Load settings
  const settings = JSON.parse(localStorage.getItem('sf_settings') || '{}');
  if(settings.dir) changeToggle('dir', settings.dir, false);
  if(settings.mode) changeToggle('mode', settings.mode, false);
  
  STATE.includeCustom = settings.includeCustom !== false;
  STATE.onlyCustom = settings.onlyCustom === true;
  if(settings.selDiff) STATE.selDiff = settings.selDiff;

  updateCheckUI('includeCustom', STATE.includeCustom);
  updateCheckUI('onlyCustom', STATE.onlyCustom);
}

function saveData() {
  localStorage.setItem('sf_custom', JSON.stringify(STATE.customCards));
  localStorage.setItem('sf_progress', JSON.stringify(STATE.progress));
  localStorage.setItem('sf_blacklist', JSON.stringify([...STATE.blacklist]));
  
  const settings = {
    dir: STATE.direction,
    mode: STATE.mode,
    includeCustom: STATE.includeCustom,
    onlyCustom: STATE.onlyCustom,
    selDiff: STATE.selDiff
  };
  localStorage.setItem('sf_settings', JSON.stringify(settings));
}

function injectCustomCards() {
  STATE.activeDecks.forEach(deck => {
    const topicCards = STATE.customCards[deck.topicId] || [];
    topicCards.forEach(c => {
       const exists = deck.cards.find(ex => ex.es === c.es && ex._custom);
       if(!exists) deck.cards.push(c);
    });
  });
}

// --- DECK NAVIGATION UI ---
const domGrid = document.getElementById('deckGrid');
const domBread = document.getElementById('deckBreadcrumbs');
const domHeaderDesc = document.getElementById('headerDesc');

function getDifficultyIcon(label) {
    const l = label.toLowerCase();
    if(l.includes('beginner')) return 'üê£';
    if(l.includes('basic')) return 'üå±'; // Basic = Seedling
    if(l.includes('intermediate')) return 'üßó';
    if(l.includes('advanced')) return 'üöÄ';
    if(l.includes('expert')) return 'üß†';
    return 'üéì';
}

function renderDecks() {
  domGrid.innerHTML = '';
  domBread.innerHTML = '';
  
  // 1. Root: Select Difficulty
  if(!STATE.selDiff) {
    domHeaderDesc.textContent = "Select your difficulty level.";
    if(!STATE.decksRaw.difficulties) return;
    STATE.decksRaw.difficulties.forEach(diff => {
      // Logic for completion color
      const status = checkDifficultyCompletion(diff.id);
      
      const el = document.createElement('div');
      el.className = 'deck-card diff-card';
      if(status === 'gold') el.classList.add('mastered-gold');
      else if(status === 'green') el.classList.add('mastered-green');

      const icon = getDifficultyIcon(diff.label);
      
      el.innerHTML = `
        <div class="diff-emoji">${icon}</div>
        <div class="diff-text-col">
            <div class="diff-title">${diff.label}</div>
            <div class="diff-sub">Difficulty</div>
        </div>
      `;
      el.onclick = () => {
        STATE.selDiff = diff.id;
        STATE.view = 'level';
        saveData();
        renderDecks();
      };
      domGrid.appendChild(el);
    });
    return;
  }

  // 2. Levels
  const diffObj = STATE.decksRaw.difficulties.find(d => d.id === STATE.selDiff);
  if(STATE.selDiff && !STATE.selLevel) {
    domHeaderDesc.textContent = `Select a level in ${diffObj.label}.`;
    addBreadcrumb("Difficulties", () => { STATE.selDiff = null; renderDecks(); });
    
    // Find levels
    const levels = new Set(STATE.activeDecks.filter(d => d.difficultyId === STATE.selDiff).map(d => d.levelIndex));
    [...levels].sort().forEach(lvl => {
      const status = checkLevelCompletion(STATE.selDiff, lvl);
      
      const el = createCard(`Level ${lvl}`, `${diffObj.label}`, () => {
        STATE.selLevel = lvl;
        renderDecks();
      });
      
      if(status === 'gold') el.classList.add('mastered-gold');
      else if(status === 'green') el.classList.add('mastered-green');
      
      domGrid.appendChild(el);
    });
    return;
  }

  // 3. Decks
  if(STATE.selDiff && STATE.selLevel) {
    domHeaderDesc.textContent = `Pick a topic to study.`;
    addBreadcrumb("Difficulties", () => { STATE.selDiff = null; STATE.selLevel = null; renderDecks(); });
    addBreadcrumb(`Level ${STATE.selLevel}`, () => { STATE.selLevel = null; renderDecks(); });
    
    // Filter decks
    const decks = STATE.activeDecks.filter(d => d.difficultyId === STATE.selDiff && d.levelIndex === STATE.selLevel);
    
    // Calculate Mix Deck Count
    let mixCount = 0;
    decks.forEach(d => { mixCount += getPlayableCount(d); });
    
    // Check Level Completion for Mix Deck Color
    const levelStatus = checkLevelCompletion(STATE.selDiff, STATE.selLevel);

    // Add Mix Deck Option
    const mixEl = createCard("‚ö° Mix All Topics", `${mixCount} cards`, () => {
       startSession(null, true); 
    });
    mixEl.classList.add('active');
    if(levelStatus === 'gold') mixEl.classList.add('mastered-gold');
    else if(levelStatus === 'green') mixEl.classList.add('mastered-green');

    domGrid.appendChild(mixEl);

    decks.forEach(d => {
      // Get Topic Name
      const topic = STATE.decksRaw.topics.find(t => t.id === d.topicId);
      const label = topic ? topic.label : d.name;
      const count = getPlayableCount(d);
      
      const status = checkDeckCompletion(d);

      const el = createCard(label, `${count} cards`, () => {
        startSession(d.id);
      });
      
      if(status === 'gold') el.classList.add('mastered-gold');
      else if(status === 'green') el.classList.add('mastered-green');

      domGrid.appendChild(el);
    });
  }
}

// --- MASTERY CHECK HELPERS ---
// Returns 'gold', 'green', or null
function getMasteryStatusForCards(cards, deckIdRef) {
    const coreCards = cards.filter(c => !c._custom);
    if(coreCards.length === 0) return null; // Only custom cards don't count for colors

    let allEsEn = true;
    let allEnEs = true;

    coreCards.forEach(c => {
        const uid = getCardId(c._realDeckId || deckIdRef, c);
        const p = STATE.progress[uid] || {};
        if((p.scoreEsEn || 0) < 4) allEsEn = false;
        if((p.scoreEnEs || 0) < 4) allEnEs = false;
    });

    // Gold = Both directions mastered
    if(allEsEn && allEnEs) return 'gold';
    
    // Green = ONE direction mastered (specifically the active one, or broadly at least one)
    if(allEsEn || allEnEs) return 'green';
    
    return null;
}

function checkDeckCompletion(deck) {
    return getMasteryStatusForCards(deck.cards, deck.id);
}

function checkLevelCompletion(diffId, levelIdx) {
    const decks = STATE.activeDecks.filter(d => d.difficultyId === diffId && d.levelIndex === levelIdx);
    if(decks.length === 0) return null;
    const allCards = decks.flatMap(d => d.cards.map(c => ({...c, _realDeckId: d.id})));
    return getMasteryStatusForCards(allCards, null);
}

function checkDifficultyCompletion(diffId) {
    const decks = STATE.activeDecks.filter(d => d.difficultyId === diffId);
    if(decks.length === 0) return null;
    const allCards = decks.flatMap(d => d.cards.map(c => ({...c, _realDeckId: d.id})));
    return getMasteryStatusForCards(allCards, null);
}

function createCard(title, sub, onClick) {
  const div = document.createElement('div');
  div.className = 'deck-card';
  div.innerHTML = `<div class="deck-title">${title}</div><div class="deck-count">${sub}</div>`;
  div.onclick = onClick;
  return div;
}

function addBreadcrumb(label, onClick) {
  const btn = document.createElement('button');
  btn.className = 'back-btn';
  btn.innerHTML = `‚Äπ ${label}`;
  btn.onclick = onClick;
  domBread.appendChild(btn);
}

function getPlayableCount(deck) {
  return deck.cards.filter(c => {
    const id = getCardId(deck.id, c);
    if(STATE.blacklist.has(id)) return false;
    if(STATE.onlyCustom && !c._custom) return false;
    if(!STATE.includeCustom && c._custom) return false;
    return true;
  }).length;
}

// --- GAME LOGIC ---
function startSession(deckId, isMix = false) {
  STATE.currentDeckId = deckId;
  STATE.sessionData = {}; // Clear session counts
  STATE.lastCardUid = null;
  STATE.isStruggleMode = false;
  STATE.sessionStats = { correctFirst: 0, struggle: 0 };
  STATE.struggleList = [];
  
  if(!isMix && !deckId) return;
  
  const pool = getPoolFromCurrentSession();
  
  if(pool.length === 0) {
    alert("No cards available with current filters!");
    return;
  }
  
  switchPanel('game');
  nextCard();
}

function startPracticeStruggle() {
  if(STATE.struggleList.length === 0) return;
  STATE.isStruggleMode = true;
  STATE.lastCardUid = null;
  document.getElementById('overlay').style.display = 'none';
  nextCard();
}

function nextCard() {
  let pool = [];
  
  if(STATE.isStruggleMode) {
    STATE.activeDecks.forEach(d => {
      d.cards.forEach(c => {
         const uid = getCardId(d.id, c);
         if(STATE.struggleList.includes(uid)) {
           pool.push({ ...c, _realDeckId: d.id, _uid: uid });
         }
      });
    });
  } else {
    pool = getPoolFromCurrentSession();
  }
  
  // Filter Pool
  const playable = pool.filter(c => {
    // No Repeats (if possible)
    if(pool.length > 1 && c._uid === STATE.lastCardUid) return false;
    
    if(STATE.isStruggleMode) return true;

    // Session Limit Logic
    const p = STATE.progress[c._uid] || {};
    // Check score based on CURRENT direction
    const score = (STATE.direction === 'es-en') ? (p.scoreEsEn || 0) : (p.scoreEnEs || 0);

    const sData = STATE.sessionData[c._uid] || { count: 0, struggle: false, postCount: 0 };
    
    // Mastered Words (Score >= 4)
    if(score >= 4) {
       // If never struggled this session, max 2 views
       if(!sData.struggle) {
         if(sData.count >= 2) return false; 
       } else {
         // If struggled this session, max 2 views AFTER struggle
         if(sData.postCount >= 2) return false;
       }
    }
    return true;
  });

  if(playable.length === 0) {
    showDeckComplete();
    return;
  }
  
  // Simple Random
  const card = playable[Math.floor(Math.random() * playable.length)];
  
  STATE.currentCard = card;
  STATE.lastCardUid = card._uid;
  renderGameCard();
}

function getPoolFromCurrentSession() {
  let pool = [];
  const isMix = !STATE.currentDeckId;
  const relevantDecks = isMix 
    ? STATE.activeDecks.filter(d => d.difficultyId === STATE.selDiff && d.levelIndex === STATE.selLevel)
    : [STATE.activeDecks.find(d => d.id === STATE.currentDeckId)];
    
  relevantDecks.forEach(d => {
    d.cards.forEach((c, idx) => {
      const uid = getCardId(d.id, c);
      if(STATE.blacklist.has(uid)) return;
      if(STATE.onlyCustom && !c._custom) return;
      if(!STATE.includeCustom && c._custom) return;
      pool.push({ ...c, _realDeckId: d.id, _realIndex: idx, _uid: uid });
    });
  });
  return pool;
}

function renderGameCard() {
  const c = STATE.currentCard;
  const isEs = STATE.direction === 'es-en';
  
  document.getElementById('gameReveal').style.display = 'none';
  document.getElementById('gameControlsJudge').style.display = 'none';
  document.getElementById('gameControlsNext').style.display = 'none';
  document.getElementById('gameControlsStart').style.display = 'flex';
  document.getElementById('btnShowAnswer').style.display = 'block';
  document.getElementById('gameInputArea').style.display = STATE.mode === 'type' ? 'block' : 'none';
  document.getElementById('gameInput').value = '';
  document.getElementById('gameFeedback').textContent = '';
  
  // Show mini controls
  document.getElementById('gameMiniControls').style.display = 'flex';

  const deckName = STATE.activeDecks.find(d => d.id === c._realDeckId)?.name || "";
  document.getElementById('gameDeckName').textContent = deckName;
  
  const p = STATE.progress[c._uid] || {};
  const score = isEs ? (p.scoreEsEn || 0) : (p.scoreEnEs || 0);

  let strLabel = "New Word";
  if(score > 0) strLabel = "Learning";
  if(score >= 4) strLabel = "Mastered";
  document.getElementById('gameStrength').textContent = strLabel;
  
  document.getElementById('gameFrontLabel').textContent = isEs ? "Spanish" : "English";
  document.getElementById('gameFrontText').textContent = isEs ? c.es : c.en;
  
  document.getElementById('gameBackLabel').textContent = isEs ? "English" : "Spanish";
  document.getElementById('gameBackText').textContent = isEs ? c.en : c.es;
  
  let ex = "";
  if(c.exampleEs && c.exampleEn) {
    ex = `"${c.exampleEs}"<br>"${c.exampleEn}"`;
  }
  document.getElementById('gameExamples').innerHTML = ex;
  
  if(STATE.mode === 'type') {
    setTimeout(() => document.getElementById('gameInput').focus(), 50);
  }
}

// Helper to clean strings for typing comparison
function cleanText(str) {
    let s = str.replace(/\s*\(.*?\)\s*/g, '');
    s = s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    s = s.toLowerCase();
    s = s.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()¬ø¬°?]/g, "");
    return s.trim();
}

function showAnswer(force = false) {
  STATE.revealTime = Date.now(); 
  
  if(STATE.mode === 'type' && !force) {
    const input = document.getElementById('gameInput');
    const val = cleanText(input.value);
    
    // Check Direction: ES-EN means target is English
    const isEs = STATE.direction === 'es-en';
    const rawTarget = isEs ? STATE.currentCard.en : STATE.currentCard.es;
    
    const targets = rawTarget.split('/').map(t => cleanText(t));
    
    // Logic: If answering in English (Target), "the" is optional.
    // We remove leading "the" from both user input and target before comparing.
    const cleanThe = (s) => s.replace(/^the\s+/, '');

    let isCorrect = false;

    if(isEs) {
        // Target is English -> apply flexible "the" rule
        const valNoThe = cleanThe(val);
        isCorrect = targets.some(t => cleanThe(t) === valNoThe);
    } else {
        // Target is Spanish -> strict "el/la" required
        isCorrect = targets.includes(val);
    }
    
    if(isCorrect) {
      document.getElementById('gameFeedback').textContent = "‚úÖ Correct!";
      document.getElementById('gameFeedback').style.color = "#4ade80";
      markCard(true, true); 
      return; 
    } else {
      document.getElementById('gameFeedback').textContent = `‚ùå Incorrect.`;
      document.getElementById('gameFeedback').style.color = "#f87171";
      markCard(false, false);
    }
  }

  document.getElementById('gameReveal').style.display = 'block';
  document.getElementById('gameControlsStart').style.display = 'none';
  document.getElementById('gameMiniControls').style.display = 'none'; // Hide settings
  
  if(STATE.mode === 'reveal') {
    document.getElementById('gameControlsJudge').style.display = 'flex';
  } else {
    document.getElementById('gameControlsNext').style.display = 'flex';
  }
}

function markCard(success, autoAdvance = true) {
  const uid = STATE.currentCard._uid;
  if(!STATE.progress[uid]) STATE.progress[uid] = { scoreEsEn: 0, scoreEnEs: 0, seen: 0 };
  if(!STATE.sessionData[uid]) STATE.sessionData[uid] = { count: 0, struggle: false, postCount: 0 };
  
  STATE.progress[uid].seen++;
  const diff = Date.now() - STATE.revealTime;
  const isEs = STATE.direction === 'es-en';

  // Session Tracking
  STATE.sessionData[uid].count++;
  if(STATE.sessionData[uid].struggle) STATE.sessionData[uid].postCount++;

  let currentScore = isEs ? STATE.progress[uid].scoreEsEn : STATE.progress[uid].scoreEnEs;

  if(success) {
     if(STATE.sessionData[uid].count === 1) STATE.sessionStats.correctFirst++;
     
     // TIME LOGIC
     if(diff <= 3000) {
       currentScore = 4;
     } else {
       if(currentScore < 4) currentScore = 3; 
       if(!STATE.struggleList.includes(uid)) STATE.struggleList.push(uid);
     }
     
     if(STATE.isStruggleMode) {
       STATE.struggleList = STATE.struggleList.filter(id => id !== uid);
     }

  } else {
     // Still Learning
     currentScore = Math.max(0, currentScore - 1);
     STATE.sessionData[uid].struggle = true;
     STATE.sessionData[uid].postCount = 0; 
     STATE.sessionStats.struggle++;
     if(!STATE.struggleList.includes(uid)) STATE.struggleList.push(uid);
  }

  // Update State
  if(isEs) STATE.progress[uid].scoreEsEn = currentScore;
  else STATE.progress[uid].scoreEnEs = currentScore;
  
  saveData();
  updateStats();
  
  if(autoAdvance) nextCard();
}

function showDeckComplete() {
  document.getElementById('overlay').style.display = 'flex';
  document.getElementById('resCorrect').textContent = STATE.sessionStats.correctFirst;
  document.getElementById('resStruggle').textContent = STATE.sessionStats.struggle; 
  
  const btnStruggle = document.getElementById('btnPracticeStruggle');
  if(STATE.struggleList.length > 0) {
    btnStruggle.style.display = 'inline-block';
    btnStruggle.textContent = `Practice Struggle Words (${STATE.struggleList.length})`;
  } else {
    btnStruggle.style.display = 'none';
  }
  
  launchConfetti();
}

function closeOverlay() {
  document.getElementById('overlay').style.display = 'none';
  switchPanel('decks');
}

function launchConfetti() {
  const colors = ['#22c55e', '#38bdf8', '#facc15', '#f43f5e'];
  for(let i=0; i<50; i++) {
    const el = document.createElement('div');
    el.className = 'confetti';
    el.style.left = Math.random()*100 + 'vw';
    el.style.backgroundColor = colors[Math.floor(Math.random()*colors.length)];
    el.style.animationDuration = (Math.random()*2 + 2) + 's';
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 4000);
  }
}

function deleteCurrentCard() {
  if(!confirm("Permanently remove this card?")) return;
  const c = STATE.currentCard;
  
  if(c._custom) {
    const topicCards = STATE.customCards[STATE.activeDecks.find(d => d.id === c._realDeckId).topicId];
    if(topicCards) {
      const idx = topicCards.findIndex(x => x.es === c.es && x.en === c.en);
      if(idx > -1) topicCards.splice(idx, 1);
    }
  } 
  
  STATE.blacklist.add(c._uid);
  saveData();
  updateStats();
  nextCard();
}

// --- GAME MINI SETTINGS ---
function toggleGameSetting(type) {
    if(type === 'dir') {
        STATE.direction = (STATE.direction === 'es-en') ? 'en-es' : 'es-en';
        renderGameCard(); 
    } else if(type === 'mode') {
        STATE.mode = (STATE.mode === 'reveal') ? 'type' : 'reveal';
        document.getElementById('gameInputArea').style.display = STATE.mode === 'type' ? 'block' : 'none';
        if(STATE.mode === 'type') document.getElementById('gameInput').focus();
    }
    
    changeToggle(type, type === 'dir' ? STATE.direction : STATE.mode, false); 
    saveData();
    updateGameMiniSettings();
}

function updateGameMiniSettings() {
    const btnDir = document.getElementById('miniBtnDir');
    const btnMode = document.getElementById('miniBtnMode');
    
    btnDir.textContent = (STATE.direction === 'es-en') ? 'Swap: ES ‚û° EN' : 'Swap: EN ‚û° ES';
    btnMode.textContent = (STATE.mode === 'reveal') ? 'Mode: Reveal' : 'Mode: Type';
    
    btnDir.classList.remove('active');
    btnMode.classList.remove('active');
    
    if(STATE.direction === 'en-es') btnDir.classList.add('active');
    if(STATE.mode === 'type') btnMode.classList.add('active');
}


// --- WORDS MANAGER UI ---
function openWordsManager() {
  document.getElementById('settings-main').style.display = 'none';
  document.getElementById('settings-words-manager').style.display = 'block';
  populateTopicFilter();
  populateDifficultyFilter();
  renderWordList();
}

function closeWordsManager() {
  document.getElementById('settings-words-manager').style.display = 'none';
  document.getElementById('settings-main').style.display = 'block';
}

function openWordsManagerFromHeader(filter) {
  switchPanel('settings');
  openWordsManager();
  document.getElementById('filterStatus').value = filter || 'all';
  renderWordList();
}

function renderWordList() {
  const container = document.getElementById('wordListContainer');
  const fStatus = document.getElementById('filterStatus').value;
  const fTopic = document.getElementById('filterTopic').value;
  const fDiff = document.getElementById('filterDifficulty').value;
  const fSort = document.getElementById('filterSort').value;
  
  container.innerHTML = 'Loading...';

  const allCardsMap = new Map();
  STATE.activeDecks.forEach(d => {
    d.cards.forEach(c => {
       const uid = getCardId(d.id, c);
       if(STATE.blacklist.has(uid)) return;
       
       const p = STATE.progress[uid] || { scoreEsEn: 0, scoreEnEs: 0, seen: 0 };
       
       // Average Score for sorting/display simplified
       const maxScore = Math.max(p.scoreEsEn || 0, p.scoreEnEs || 0); 
       
       // Status Filter
       if(fStatus === 'known' && maxScore < 4) return;
       if(fStatus === 'learning' && (maxScore >= 4 || p.seen === 0)) return;

       // Topic Filter
       if(fTopic !== 'all' && d.topicId !== fTopic) return;
       
       // Difficulty Filter
       if(fDiff === 'custom') {
           if(!c._custom) return;
       } else if(fDiff !== 'all') {
           if(d.difficultyId !== fDiff) return;
       }

       allCardsMap.set(uid, { ...c, _deckName: d.name, _diffId: d.difficultyId, _score: maxScore, _uid: uid });
    });
  });
  
  let list = Array.from(allCardsMap.values());
  
  if(fSort === 'az') {
    list.sort((a,b) => a.es.localeCompare(b.es));
  } else if (fSort === 'diff') {
     list.sort((a,b) => a._score - b._score);
  }
  
  container.innerHTML = '';
  if(list.length === 0) {
    container.innerHTML = '<div style="padding:20px; text-align:center; color:var(--text-muted)">No words match filter.</div>';
    return;
  }
  
  const renderLimit = list.slice(0, 100); 
  
  renderLimit.forEach(c => {
    const scoreClass = c._score >= 4 ? 'score-4' : (c._score === 3 ? 'score-3' : (c._score > 0 ? 'score-1' : 'score-0'));
    
    let bgClass = '';
    if(c._custom) bgClass = 'bg-custom';
    else if(c._diffId) bgClass = `bg-diff-${c._diffId}`; 

    const el = document.createElement('div');
    el.className = `word-row ${bgClass}`;
    el.innerHTML = `
      <div class="word-info">
        <div class="word-main">
          <span class="word-score ${scoreClass}"></span>
          ${c.es} 
          <span style="font-weight:400; color:var(--text-muted)">‚Äî ${c.en}</span>
        </div>
        <div class="word-sub">
          ${c._deckName}
          ${c._custom ? '<span class="word-tag">Custom</span>' : ''}
        </div>
      </div>
      <button class="btn-icon" onclick="deleteWordByUid('${c._uid}')">üóë</button>
    `;
    container.appendChild(el);
  });
  
  if(list.length > 100) {
     const more = document.createElement('div');
     more.style.textAlign = 'center';
     more.style.fontSize = '12px';
     more.style.padding = '10px';
     more.style.color = 'var(--text-muted)';
     more.textContent = `...and ${list.length - 100} more`;
     container.appendChild(more);
  }
}

function deleteWordByUid(uid) {
  if(!confirm("Permanently delete word?")) return;
  STATE.blacklist.add(uid);
  saveData();
  renderWordList(); 
  updateStats();
}

function populateTopicFilter() {
  const sel = document.getElementById('filterTopic');
  sel.innerHTML = '<option value="all">All Categories</option>';
  if(STATE.decksRaw.topics) {
    STATE.decksRaw.topics.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.label;
      sel.appendChild(opt);
    });
  }
}

function populateDifficultyFilter() {
    const sel = document.getElementById('filterDifficulty');
    sel.innerHTML = '<option value="all">All Difficulties</option>';
    if(STATE.decksRaw.difficulties) {
        STATE.decksRaw.difficulties.forEach(d => {
            const opt = document.createElement('option');
            opt.value = d.id;
            opt.textContent = d.label;
            sel.appendChild(opt);
        });
    }
    const optCustom = document.createElement('option');
    optCustom.value = 'custom';
    optCustom.textContent = 'Manually added';
    sel.appendChild(optCustom);
}

// --- ADD CARD UI ---
function populateAddDropdown() {
  const sel = document.getElementById('addTopicSelect');
  sel.innerHTML = '';
  if(STATE.decksRaw.topics) {
    STATE.decksRaw.topics.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.label;
      sel.appendChild(opt);
    });
  }
}

function toggleAddEx() {
  const div = document.getElementById('divAddEx');
  const btn = document.getElementById('btnToggleEx');
  if(div.style.display === 'none') {
    div.style.display = 'block';
    btn.textContent = '‚ûñ Hide Examples';
  } else {
    div.style.display = 'none';
    btn.textContent = '‚ûï Add Examples (Optional)';
  }
}

function onAddSubmit() {
  const es = document.getElementById('addEs').value.trim();
  const en = document.getElementById('addEn').value.trim();
  const topicId = document.getElementById('addTopicSelect').value;
  const exEs = document.getElementById('addExEs').value.trim();
  const exEn = document.getElementById('addExEn').value.trim();
  
  if(!es || !en || !topicId) {
    document.getElementById('addMsg').textContent = "Please fill required fields.";
    document.getElementById('addMsg').style.color = "#f87171";
    return;
  }
  
  const newCard = { es, en, exampleEs: exEs, exampleEn: exEn, _custom: true };
  
  if(!STATE.customCards[topicId]) STATE.customCards[topicId] = [];
  STATE.customCards[topicId].push(newCard);
  
  STATE.activeDecks.forEach(d => {
    if(d.topicId === topicId) {
       d.cards.push(newCard);
    }
  });
  
  saveData();
  updateStats();
  
  const topicLabel = STATE.decksRaw.topics.find(t=>t.id===topicId)?.label || "Topic";
  document.getElementById('addMsg').textContent = `Added to ${topicLabel} decks!`;
  document.getElementById('addMsg').style.color = "#4ade80";
  
  document.getElementById('addEs').value = '';
  document.getElementById('addEn').value = '';
  document.getElementById('addExEs').value = '';
  document.getElementById('addExEn').value = '';
  document.getElementById('addEs').focus();
  
  setTimeout(() => document.getElementById('addMsg').textContent = '', 2000);
}


// --- UTILS ---
function switchPanel(panelId) {
  document.querySelectorAll('.panel').forEach(el => el.classList.remove('active'));
  document.getElementById('panel-'+panelId).classList.add('active');
  
  document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
  const navBtn = document.querySelector(`.nav-tab[data-panel="${panelId}"]`);
  if(navBtn) navBtn.classList.add('active');
  
  if(panelId === 'decks') renderDecks();
  if(panelId === 'settings') { 
    closeWordsManager();
  }
}

function changeToggle(group, val, shouldSave=true) {
  document.querySelectorAll(`.toggle-btn[data-group="${group}"]`).forEach(btn => {
    if(btn.dataset.val === val) btn.classList.add('active');
    else btn.classList.remove('active');
  });
  
  if(group === 'dir') STATE.direction = val;
  if(group === 'mode') STATE.mode = val;
  
  updateGameMiniSettings(); 
  
  if(shouldSave) saveData();
}

function toggleSetting(key) {
  STATE[key] = !STATE[key];
  saveData();
  updateCheckUI(key, STATE[key]);
  renderDecks(); 
}

function updateCheckUI(key, val) {
  const el = document.getElementById('btnToggle' + key.charAt(0).toUpperCase() + key.slice(1));
  if(!el) return;
  if(val) {
    el.classList.add('checked');
    el.querySelector('.status-icon').textContent = '‚úì';
  } else {
    el.classList.remove('checked');
    el.querySelector('.status-icon').textContent = '‚óã';
  }
}

function updateStats() {
  let known = 0, learning = 0;
  // Stats reflect CURRENT direction setting (simple heuristic)
  const isEs = STATE.direction === 'es-en';

  Object.entries(STATE.progress).forEach(([uid, p]) => {
    if(STATE.blacklist.has(uid)) return;
    const score = isEs ? (p.scoreEsEn||0) : (p.scoreEnEs||0);
    
    if(score >= 4) {
        known++;
    } else if (p.seen > 0) { 
        learning++;
    }
  });
  
  let total = 0;
  const uniqueAll = new Set();
  STATE.activeDecks.forEach(d => {
      d.cards.forEach(c => {
         const uid = getCardId(d.id, c);
         if(!STATE.blacklist.has(uid)) uniqueAll.add(uid);
      });
  });
  total = uniqueAll.size;

  document.getElementById('statKnown').textContent = known;
  document.getElementById('statLearning').textContent = learning;
  document.getElementById('statTotal').textContent = total;
}

function getCardId(deckId, card) {
  return `${deckId}:${card.es.replace(/\s/g,'')}`;
}

function resetAllData() {
  if(confirm("Reset ALL data? Progress, custom cards, and settings will be lost.")) {
    localStorage.clear();
    location.reload();
  }
}

// --- BINDINGS ---
function bindEvents() {
  document.querySelectorAll('.nav-tab').forEach(btn => {
    btn.onclick = () => switchPanel(btn.dataset.panel);
  });
  
  document.querySelectorAll('.toggle-btn').forEach(btn => {
    btn.onclick = () => changeToggle(btn.dataset.group, btn.dataset.val);
  });
  
  document.getElementById('btnShowAnswer').onclick = () => showAnswer();
  document.getElementById('btnEasy').onclick = () => markCard(true);
  document.getElementById('btnHard').onclick = () => markCard(false);
  document.getElementById('btnNextCard').onclick = () => nextCard();
  document.getElementById('btnDeleteCard').onclick = deleteCurrentCard;
  
  document.getElementById('gameInput').onkeydown = (e) => {
    if(e.key === 'Enter') showAnswer();
  };
  
  document.getElementById('btnAddSubmit').onclick = onAddSubmit;
  document.getElementById('btnResetData').onclick = resetAllData;
}

// Start
init();

</script>
</body>
</html>

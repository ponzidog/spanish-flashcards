<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spanish Flashcards ‚Äì Semi-Beginner Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- PWA bits -->
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#020617" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Spanish Flashcards" />

  <!-- Modern font: Inter -->
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
  />

  <style>
    :root {
      --bg: #020617;
      --bg-alt: #020617;
      --accent: #22c55e;
      --accent-soft: rgba(34, 197, 94, 0.14);
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
      --card-bg: #020617;
      --border-subtle: rgba(148, 163, 184, 0.35);
      --danger: #f97373;
      --danger-soft: rgba(239, 68, 68, 0.18);
      --radius-lg: 20px;
      --shadow-soft: 0 22px 55px rgba(15, 23, 42, 0.95);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      max-width: 100%;
      overflow-x: hidden;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont,
        "SF Pro Text", "Segoe UI", sans-serif;
      background: radial-gradient(circle at top left, #111827, #020617 55%, #020617);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 960px;
      margin: 8px auto;
      border-radius: 26px;
      background: radial-gradient(circle at top left, #020617, #020617 40%, #020617);
      border: 1px solid rgba(148, 163, 184, 0.45);
      box-shadow: var(--shadow-soft);
      overflow: hidden;
      position: relative;
    }

    .app-header {
      padding: 18px 18px 10px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.35);
      background: radial-gradient(circle at top left, #020617, #020617);
      position: relative;
      z-index: 10;
    }

    .header-top {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: flex-start;
      margin-bottom: 10px;
    }

    .logo-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .logo-title {
      font-weight: 600;
      letter-spacing: 0.09em;
      font-size: 11px;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .logo-main {
      font-size: 22px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .logo-pill {
      font-size: 11px;
      text-transform: uppercase;
      background: var(--accent-soft);
      border-radius: 999px;
      padding: 2px 8px;
      color: #bbf7d0;
      border: 1px solid rgba(34, 197, 94, 0.45);
    }

    .deck-description {
      margin-top: 2px;
      font-size: 13px;
      color: var(--text-muted);
      max-width: 340px;
    }

    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: flex-end;
    }

    .stat-pill {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      color: var(--text-muted);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: rgba(15, 23, 42, 0.95);
    }

    .stat-pill strong {
      color: var(--text-main);
      font-weight: 600;
    }

    .stat-pill--accent {
      border-color: rgba(34, 197, 94, 0.85);
      background: var(--accent-soft);
      color: #bbf7d0;
    }

    .stat-pill--danger {
      border-color: rgba(239, 68, 68, 0.9);
      background: var(--danger-soft);
      color: #fecaca;
    }

    /* Top nav with icons */
    .top-nav {
      margin-top: 10px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .top-nav-btn {
      flex: 1 1 0;
      min-width: 0;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.95);
      color: var(--text-main);
      font-size: 13px;
      padding: 7px 10px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: background 0.15s ease, border-color 0.15s ease,
        transform 0.08s ease, box-shadow 0.1s ease;
      white-space: nowrap;
    }

    .top-nav-btn span.label {
      font-size: 12px;
    }

    .top-nav-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #052e16;
      box-shadow: 0 0 0 1px rgba(22, 163, 74, 0.45);
      font-weight: 600;
    }

    .top-nav-btn:hover {
      transform: translateY(-0.5px);
      border-color: rgba(248, 250, 252, 0.85);
    }

    .top-panels {
      margin-top: 10px;
    }

    .top-panel {
      border-radius: 18px;
      border: 1px dashed rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.96);
      padding: 10px 12px;
      margin-bottom: 8px;
      display: none;
    }

    .top-panel.active {
      display: block;
    }

    .panel-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    /* Deck list in panel */
    .deck-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 12px;
      align-items: center;
    }

    .deck-filters label {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .deck-filters select {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      padding: 7px 11px;
      color: var(--text-main);
      font-size: 12px;
      outline: none;
    }

    .deck-filters select:focus {
      border-color: var(--accent);
    }

    .deck-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .deck-item {
      flex: 1 1 calc(50% - 6px);
      min-width: 140px;
      border-radius: 12px;
      padding: 8px 10px;
      cursor: pointer;
      border: 1px solid transparent;
      display: flex;
      flex-direction: column;
      gap: 2px;
      transition: background 0.15s ease, border-color 0.15s ease,
        transform 0.1s ease;
      font-size: 13px;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
    }

    .deck-item:hover {
      background: rgba(15, 23, 42, 0.98);
      border-color: rgba(148, 163, 184, 0.9);
      transform: translateY(-1px);
    }

    .deck-item.active {
      background: radial-gradient(circle at top left, #22c55e26, #020617);
      border-color: var(--accent);
    }

    .deck-name {
      font-weight: 600;
    }

    .deck-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Session settings panel */
    .settings-box {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .settings-row span.label {
      font-size: 12px;
      color: var(--text-main);
    }

    .pill-toggle {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 2px;
      background: #020617;
      border: 1px solid rgba(148, 163, 184, 0.6);
      gap: 4px;
      font-size: 11px;
    }

    .pill-toggle button {
      border: none;
      outline: none;
      background: transparent;
      color: var(--text-muted);
      padding: 3px 8px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.15s ease, color 0.15s ease;
      white-space: nowrap;
    }

    .pill-toggle button.active {
      background: var(--accent);
      color: #052e16;
      font-weight: 600;
    }

    .reset-btn {
      margin-top: 4px;
      font-size: 11px;
      padding: 6px 8px;
      background: rgba(248, 250, 252, 0.02);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      color: var(--text-muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .reset-btn:hover {
      background: rgba(239, 68, 68, 0.12);
      border-color: var(--danger);
      color: #fecaca;
    }

    /* Add-card panel */
    .add-card {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 12px;
    }

    .add-card-info {
      font-size: 11px;
      color: var(--text-muted);
    }

    .add-card form {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px 10px;
      margin-top: 4px;
    }

    .add-card label {
      font-size: 11px;
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .add-card input,
    .add-card select,
    .add-card textarea {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      padding: 10px 12px;
      color: var(--text-main);
      font-size: 16px; /* >=16px to avoid mobile zoom */
      outline: none;
      width: 100%;
    }

    .add-card textarea {
      border-radius: 14px;
      min-height: 60px;
      resize: vertical;
    }

    .add-card input::placeholder,
    .add-card textarea::placeholder {
      color: #6b7280;
    }

    .add-card input:focus,
    .add-card select:focus,
    .add-card textarea:focus {
      border-color: var(--accent);
    }

    .add-card-actions {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    .add-feedback {
      font-size: 11px;
      color: var(--text-muted);
    }

    .add-card-examples,
    .add-card-examples-fields {
      grid-column: 1 / -1;
    }

    .add-card-examples-fields {
      display: none;
      gap: 6px 10px;
      margin-top: 4px;
    }

    .add-card-examples-fields label textarea {
      width: 100%;
    }

    .btn-lg {
      padding: 10px 18px;
      font-size: 14px;
      font-weight: 600;
    }

    /* Words panel (view/edit/delete) */
    .words-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 12px;
      flex-wrap: wrap;
    }

    .words-deck-select {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      padding: 7px 11px;
      color: var(--text-main);
      font-size: 12px;
      outline: none;
    }

    .words-deck-select:focus {
      border-color: var(--accent);
    }

    .words-list {
      max-height: 260px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .word-row {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 12px;
      border: 1px solid rgba(30, 64, 175, 0.4);
      background: rgba(15, 23, 42, 0.96);
    }

    .word-row-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .word-row-line {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .word-row-line span.label {
      font-size: 11px;
      color: var(--text-muted);
      min-width: 36px;
    }

    .word-input {
      flex: 1;
      background: rgba(15, 23, 42, 0.98);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      padding: 7px 10px;
      font-size: 14px;
      color: var(--text-main);
      outline: none;
    }

    .word-input:focus {
      border-color: var(--accent);
    }

    .word-row-deck {
      font-size: 11px;
      color: var(--text-muted);
    }

    .word-row-actions {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .btn-xs {
      padding: 5px 8px;
      font-size: 11px;
    }

    .words-empty {
      font-size: 12px;
      color: var(--text-muted);
    }

    /* Main / game area */
    .main {
      padding: 14px 18px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: radial-gradient(circle at top left, #020617, #020617);
      position: relative;
      z-index: 1;
    }

    .card-shell {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .card {
      width: 100%;
      max-width: 640px;
      min-height: 260px;
      border-radius: 26px;
      background: var(--card-bg);
      border: 1px solid rgba(148, 163, 184, 0.55);
      padding: 22px 22px 18px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(
        circle at top left,
        rgba(56, 189, 248, 0.18),
        transparent 58%
      );
      pointer-events: none;
    }

    .card-inner {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      height: 100%;
      justify-content: space-between;
    }

    .card-header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .card-deck-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
    }

    .card-sub-label {
      font-size: 11px;
      color: var(--text-muted);
    }

    .card-body {
      margin-top: 16px;
      margin-bottom: 16px;
    }

    .card-front-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.22em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .card-front-text {
      font-size: 40px;
      font-weight: 700;
      letter-spacing: 0.03em;
      color: var(--text-main);
      word-wrap: break-word;
    }

    .card-back {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px dashed rgba(148, 163, 184, 0.6);
    }

    .card-back-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .card-back-main {
      font-size: 22px;
      font-weight: 500;
      margin-bottom: 6px;
      color: var(--text-main);
    }

    .card-back-example {
      font-size: 13px;
      color: var(--text-muted);
    }

    .card-back-example span {
      display: block;
      margin-top: 2px;
    }

    .typed-answer {
      margin-top: 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .typed-answer input {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.75);
      padding: 10px 14px;
      color: var(--text-main);
      font-size: 18px; /* >=16px to avoid mobile zoom */
      outline: none;
      width: 100%;
    }

    .typed-answer input::placeholder {
      color: #6b7280;
    }

    .typed-answer input:focus {
      border-color: var(--accent);
    }

    .typed-feedback {
      font-size: 12px;
      min-height: 16px;
      color: var(--text-muted);
    }

    .card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-top: 8px;
    }

    .hint {
      font-size: 11px;
      color: var(--text-muted);
      max-width: 260px;
    }

    .card-primary-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: flex-end;
}
/* Make the three main buttons equal width */
.card-primary-actions .btn-main {
  flex: 1 1 0;
  justify-content: center;
}

/* Delete-current-card button anchored to the left */
.card-delete-current-btn {
  margin-right: auto;
  opacity: 0.8;
}

.card-delete-current-btn:hover {
  opacity: 1;
}


    .btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.96);
      color: var(--text-main);
      font-size: 13px;
      padding: 8px 14px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s ease, border-color 0.15s ease,
        transform 0.08s ease;
      white-space: nowrap;
    }

    .btn-ghost {
      background: transparent;
    }

    .btn-accent {
      background: var(--accent);
      border-color: #22c55e;
      color: #052e16;
      font-weight: 600;
    }

    .btn-danger {
      background: rgba(239, 68, 68, 0.16);
      border-color: var(--danger);
      color: #fecaca;
    }

    .btn:hover {
      transform: translateY(-0.5px);
      border-color: rgba(248, 250, 252, 0.85);
    }

    .btn:active {
      transform: translateY(1px) scale(0.98);
    }

    .btn:disabled {
      opacity: 0.55;
      cursor: default;
      transform: none;
    }

    .session-controls {
      width: 100%;
      max-width: 640px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      flex-wrap: wrap;
    }

    .session-left,
    .session-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .session-info {
      font-size: 12px;
      color: var(--text-muted);
    }

    .badge {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      font-size: 11px;
      color: var(--text-muted);
      background: rgba(15, 23, 42, 0.96);
    }

    /* Stats panel below game */
    .stats-bar {
      width: 100%;
      max-width: 640px;
      margin: 8px auto 0;
      display: flex;
      justify-content: flex-start;
    }

    .stats-panel {
      width: 100%;
      max-width: 640px;
      margin: 8px auto 0;
      border-radius: 18px;
      border: 1px dashed rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.96);
      padding: 10px 12px;
      font-size: 12px;
      display: none;
    }

    .stats-panel-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
    }

    .stats-panel-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    /* Deck-complete overlay + confetti */
    .deck-complete-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.78);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 60;
    }

    .deck-complete-card {
      background: radial-gradient(circle at top left, #020617, #020617 40%);
      border-radius: 24px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: var(--shadow-soft);
      padding: 18px 20px 16px;
      max-width: 380px;
      width: 90%;
    }

    .deck-complete-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .deck-complete-text {
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    .deck-complete-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }

    .confetti-container {
      position: fixed;
      inset: 0;
      overflow: hidden;
      pointer-events: none;
      z-index: 80;
    }

    .confetti-piece {
      position: absolute;
      width: 8px;
      height: 14px;
      opacity: 0.9;
      border-radius: 2px;
      animation: confetti-fall 2.8s linear forwards;
    }

    @keyframes confetti-fall {
      to {
        transform: translate3d(0, 110vh, 0) rotateZ(360deg);
        opacity: 0;
      }
    }

    /* Responsive */
    @media (max-width: 880px) {
      .app {
        border-radius: 0;
        margin: 0;
      }

      .card {
        padding: 18px 18px 16px;
        min-height: 230px;
      }

      .card-front-text {
        font-size: 32px;
      }

      .add-card form {
        grid-template-columns: 1fr;
      }

      .add-card-examples-fields {
        display: none;
      }
    }

    @media (max-width: 540px) {
      .header-top {
        flex-direction: column;
        align-items: flex-start;
      }

      .deck-description {
        max-width: 100%;
      }

      .stats {
        justify-content: flex-start;
      }

      .card-front-text {
        font-size: 28px;
      }

      .session-controls {
        flex-direction: column;
        align-items: flex-start;
      }

      .top-nav-btn span.label {
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="app-header">
      <div class="header-top">
        <div class="logo-block">
          <div class="logo-title">Spanish trainer</div>
          <div class="logo-main">
            FlashCards
            <span class="logo-pill">semi-beginner</span>
          </div>
          <p class="deck-description" id="deckDescription">
            Choose a deck, then practice by revealing or typing the answer.
          </p>
        </div>
        <div class="stats">
          <div class="stat-pill stat-pill--accent">
            Session cards: <strong id="statSessionSeen">0</strong>
          </div>
          <div class="stat-pill">
            Knew it: <strong id="statSessionKnew">0</strong>
          </div>
          <div class="stat-pill stat-pill--danger">
            Still learning: <strong id="statSessionLearning">0</strong>
          </div>
          <div class="stat-pill">
            Total words: <strong id="statTotalWords">0</strong>
          </div>
        </div>
      </div>

      <!-- Icon bar -->
      <div class="top-nav" id="topNav">
        <button class="top-nav-btn active" data-panel="decks">
          üìö <span class="label">Decks</span>
        </button>
        <button class="top-nav-btn" data-panel="session">
          üéØ <span class="label">Session</span>
        </button>
        <button class="top-nav-btn" data-panel="add">
          ‚ûï <span class="label">Add word</span>
        </button>
        <button class="top-nav-btn" data-panel="words">
          üìù <span class="label">Words</span>
        </button>
      </div>

      <!-- Panels -->
      <div class="top-panels">
        <!-- Decks -->
        <div class="top-panel active" id="panel-decks">
          <div class="panel-title">Decks</div>
          <div class="deck-filters">
            <label>
              Difficulty
              <select id="difficultySelect"></select>
            </label>
            <label>
              Level
              <select id="levelSelect"></select>
            </label>
          </div>
          <div class="deck-list" id="deckList"></div>
        </div>

        <!-- Session settings -->
        <div class="top-panel" id="panel-session">
          <div class="panel-title">Session settings</div>
          <div class="settings-box">
            <div class="settings-row">
              <span class="label">Direction</span>
              <div class="pill-toggle" id="directionToggle">
                <button data-direction="es-en" class="active">ES ‚Üí EN</button>
                <button data-direction="en-es">EN ‚Üí ES</button>
              </div>
            </div>

            <div class="settings-row">
              <span class="label">Answer mode</span>
              <div class="pill-toggle" id="answerModeToggle">
                <button data-answer-mode="reveal" class="active">Reveal</button>
                <button data-answer-mode="type">Type</button>
              </div>
            </div>

            <button class="reset-btn" id="resetProgressBtn">
              ‚ü≤ Reset learning progress
            </button>

            <div style="font-size: 11px; margin-top: 4px;">
              Focus mode is always on: words you‚Äôre still learning appear much more
              often than strong ones.
            </div>
          </div>
        </div>

        <!-- Add word -->
        <div class="top-panel" id="panel-add">
          <div class="panel-title">Add your own words</div>
          <div class="add-card">
            <div class="add-card-info">
              Saved locally in your browser. They‚Äôll also be included in the
              <strong>All decks</strong> mix.
            </div>
            <form id="addCardForm">
              <label>
                Spanish *
                <input type="text" id="addEs" placeholder="por ejemplo: la pared" />
              </label>
              <label>
                English *
                <input type="text" id="addEn" placeholder="for example: the wall" />
              </label>

              <div class="add-card-examples">
                <button type="button" class="btn btn-ghost btn-xs" id="toggleExamplesBtn">
                  ‚ûï Add examples
                </button>
              </div>

              <div class="add-card-examples-fields" id="exampleFields">
                <label>
                  Example ES
                  <textarea
                    id="addExampleEs"
                    placeholder="optional sentence in Spanish"
                  ></textarea>
                </label>
                <label>
                  Example EN
                  <textarea
                    id="addExampleEn"
                    placeholder="optional sentence in English"
                  ></textarea>
                </label>
              </div>

              <label>
                Deck
                <select id="addDeckSelect"></select>
              </label>
              <div class="add-card-actions">
                <span class="add-feedback" id="addFeedback">
                  Tip: Add words you meet in real life (books, series, etc.).
                </span>
                <button type="submit" class="btn btn-accent btn-lg">
                  ‚ûï Add word
                </button>
              </div>
            </form>
          </div>
        </div>

        <!-- Words view/edit panel -->
        <div class="top-panel" id="panel-words">
          <div class="panel-title">All words</div>
          <div class="words-controls">
            <span>View deck:</span>
            <select id="wordsDeckSelect" class="words-deck-select"></select>
          </div>
          <div class="words-list" id="wordsList"></div>
        </div>
      </div>
    </header>

    <!-- MAIN / GAME -->
    <main class="main">
      <section class="card-shell">
        <div class="card" id="card">
          <div class="card-inner">
            <div>
              <div class="card-header-row">
                <div class="card-deck-label" id="cardDeckLabel">All decks</div>
                <div class="card-sub-label" id="cardStrengthLabel">
                  New word
                </div>
              </div>

              <div class="card-body">
                <div class="card-front-label" id="cardFrontLabel">Spanish</div>
                <div class="card-front-text" id="cardFrontText">
                  Choose a deck to begin
                </div>

                <div class="typed-answer" id="typedAnswerContainer" style="display: none;">
                  <input
                    type="text"
                    id="typedAnswerInput"
                    placeholder="Type the translation and press Enter‚Ä¶"
                    autocomplete="off"
                  />
                  <div class="typed-feedback" id="typedFeedback"></div>
                </div>

                <div class="card-back" id="cardBack" style="display: none;">
                  <div class="card-back-label">Answer</div>
                  <div class="card-back-main" id="cardBackMain"></div>
                  <div class="card-back-example" id="cardBackExample"></div>
                </div>
              </div>
            </div>

            <div class="card-footer">
              <div class="hint" id="cardHint">
                Click ‚ÄúShow answer‚Äù or press the spacebar.
              </div>
              <div class="card-primary-actions">
   <!-- NEW: delete current card button (bottom-left) -->
  <button
    class="btn btn-ghost btn-xs card-delete-current-btn"
    id="deleteCurrentBtn"
    type="button"
  >
    üóë Remove card
  </button>

  <!-- Main action buttons: equal size -->
  <button class="btn btn-ghost btn-main" id="showAnswerBtn">
    üëÄ Show answer
  </button>
  <button class="btn btn-danger btn-main" id="learningBtn" disabled>
    ü§î Still learning
  </button>
  <button class="btn btn-accent btn-main" id="knewItBtn" disabled>
    ‚úÖ I knew it
  </button>
</div>
            </div>
          </div>
        </div>

        <div class="session-controls">
          <div class="session-left">
            <span class="session-info" id="sessionInfo">
              Start by picking a deck. Tough words will appear more often than strong ones.
            </span>
          </div>
          <div class="session-right">
            <span class="badge" id="cardIndexBadge">‚Äî</span>
            <button class="btn btn-ghost" id="skipBtn" disabled>
              ‚è≠ Skip word
            </button>
          </div>
        </div>

        <div class="stats-bar">
          <button class="btn btn-ghost btn-xs" id="statsToggleBtn">üìä Stats</button>
        </div>
        <div class="stats-panel" id="statsPanel">
          <div class="stats-panel-row">
            <div class="stat-pill stat-pill--accent">
              Already know: <strong id="statsKnownCount">0</strong>
            </div>
            <div class="stat-pill">
              Don‚Äôt know yet: <strong id="statsDontKnowCount">0</strong>
            </div>
            <div class="stat-pill stat-pill--danger">
              Struggle words: <strong id="statsStruggleCount">0</strong>
            </div>
          </div>
          <div class="stats-panel-actions">
            <button class="btn btn-ghost btn-xs" id="statsExcludeKnownBtn">
              üö´ Exclude known words this session
            </button>
            <button class="btn btn-danger btn-xs" id="statsDeleteKnownBtn">
              üóë Delete known words from file
            </button>
          </div>
        </div>
      </section>
    </main>

    <!-- Deck complete overlay -->
    <div class="deck-complete-overlay" id="deckCompleteOverlay">
      <div class="deck-complete-card">
        <div class="deck-complete-title" id="deckCompleteTitle">üéâ Congrats!</div>
        <div class="deck-complete-text" id="deckCompleteText">
          You went through every card in this deck.
        </div>
        <div class="deck-complete-actions">
          <button class="btn btn-accent" id="deckCompleteStruggleBtn">
            üîÅ Practice struggle words
          </button>
          <button class="btn btn-ghost" id="deckCompleteCloseBtn">
            Close
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- JS -->
  <script>
    /******************************************************
     * 1. DATA ‚Äì semi-beginner decks (static base)
     ******************************************************/
    
    const DECKS_URL = "decks.json";
    let DECKS = [];
    let DIFFICULTIES = [];
    let TOPICS = [];
    let currentDifficultyId = null;
    let currentLevelIndex = 1;
    let lastPlayedDifficultyId = null;
    let lastPlayedLevelIndex = 1;

    async function loadDecksFromJson() {
      try {
        const res = await fetch("./decks.json", { cache: "no-store" });
        if (!res.ok) {
          throw new Error("Failed to load decks.json");
        }
        const data = await res.json();
        DIFFICULTIES = (data.difficulties || []).slice().sort((a, b) => {
          const ao = typeof a.order === "number" ? a.order : 999;
          const bo = typeof b.order === "number" ? b.order : 999;
          return ao - bo;
        });
        TOPICS = data.topics || [];
        const baseDecks = data.decks || [];

        const decks = [
          {
            id: "all",
            name: "All words",
            description: "All difficulties, topics, and levels combined.",
            cards: [],
            meta: {},
            difficultyId: "*all",
            levelIndex: 0
          },
        ];

        baseDecks.forEach((deck) => {
          if (!deck || !deck.id) return;
          decks.push({
            id: deck.id,
            name: deck.name || deck.id,
            description: deck.description || "",
            cards: (deck.cards || []).map((c) => ({
              es: c.es,
              en: c.en,
              exampleEs: c.exampleEs,
              exampleEn: c.exampleEn,
            })),
            difficultyId: deck.difficultyId || null,
            topicId: deck.topicId || null,
            levelIndex:
              typeof deck.levelIndex === "number"
                ? deck.levelIndex
                : parseInt(deck.levelIndex, 10) || 1,
          });
        });

        DECKS = decks;

        if (!currentDifficultyId && DIFFICULTIES.length) {
          currentDifficultyId = DIFFICULTIES[0].id;
        }
        if (!lastPlayedDifficultyId) {
          lastPlayedDifficultyId = currentDifficultyId;
        }
        currentLevelIndex = currentLevelIndex || 1;
        lastPlayedLevelIndex = lastPlayedLevelIndex || currentLevelIndex;
      } catch (err) {
        console.error("Error loading decks.json:", err);
        DECKS = [
          {
            id: "all",
            name: "All words",
            description:
              "Could not load decks.json ‚Äì using an empty placeholder deck.",
            cards: [],
            meta: {},
          },
        ];
        const errorMsg =
          "Could not load decks.json. Make sure it is in the same folder as index.html.";
        if (typeof cardFrontTextEl !== "undefined") {
          cardFrontTextEl.textContent = errorMsg;
        }
        if (typeof cardHintEl !== "undefined") {
          cardHintEl.textContent = "Reload the page after fixing the file location.";
        }
      }
    }

function rebuildAllDeck() {
      const allDeck = DECKS.find((d) => d.id === "all");
      allDeck.cards = [];
      DECKS.forEach((deck) => {
        if (deck.id === "all") return;
        deck.cards.forEach((card, index) => {
          allDeck.cards.push({
            ...card,
            _sourceDeckId: deck.id,
            _sourceIndex: index,
          });
        });
      });
      allDeck.meta = {
        fromDecks: DECKS.filter((d) => d.id !== "all").map((d) => d.id),
      };
    }

    /******************************************************
     * 2. STATE & STORAGE
     ******************************************************/
    const STORAGE_KEY = "spanishFlashAppProgress_v1";
    const STORAGE_CUSTOM = "spanishFlashAppCustomCards_v1";

    let progressMap = {}; // { cardKey: { strength, seen, lastSeen, correct, wrong, firstAnswerCorrect } }
    let customCardsStore = {}; // { deckId: [ card, ... ] }

    let currentDeckId = "all";
    let currentDirection = "es-en"; // "es-en" or "en-es"
    let currentMode = "focus"; // always focus
    let currentAnswerMode = "reveal"; // "reveal" or "type"
    let currentCardRef = null; // { deckId, index }
    let currentRevealed = false;

    const sessionStats = {
      seen: 0,
      knew: 0,
      learning: 0,
    };

    let typeAnswerChecked = false;
    let lastTypeWasCorrect = null;

    // Session filters / completion
    let currentSessionFilter = "all"; // "all" | "struggle"
    let excludeKnownFromSession = false;
    let sessionSeenByDeck = {}; // { deckId: Set(cardIds) }
    let deckCompletionShown = {}; // { deckId: true }
    let lastCompletedDeckId = null;
    let deletedInSession = {}; // { deckId: Set(indexes) }

function markCardDeletedForSession(deckId, index) {
  if (!deletedInSession[deckId]) {
    deletedInSession[deckId] = new Set();
  }
  deletedInSession[deckId].add(index);
}


    function loadProgress() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (data && typeof data === "object") {
          progressMap = data;
        }
      } catch (e) {
        console.warn("Could not load progress:", e);
      }
    }

    function saveProgress() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(progressMap));
      } catch (e) {
        console.warn("Could not save progress:", e);
      }
    }

    function resetProgress() {
      progressMap = {};
      saveProgress();
      updateStatsUI();
      updateCardStrengthLabel(null);
    }

    function loadCustomCards() {
      try {
        const raw = localStorage.getItem(STORAGE_CUSTOM);
        if (!raw) return;
        const data = JSON.parse(raw) || {};
        customCardsStore = data;
        Object.entries(data).forEach(([deckId, cards]) => {
          const deck = DECKS.find((d) => d.id === deckId);
          if (!deck) return;
          cards.forEach((card) => {
            deck.cards.push(card);
          });
        });
      } catch (e) {
        console.warn("Could not load custom cards:", e);
      }
    }

    function saveCustomCards() {
      try {
        localStorage.setItem(STORAGE_CUSTOM, JSON.stringify(customCardsStore));
      } catch (e) {
        console.warn("Could not save custom cards:", e);
      }
    }

    function syncCustomStoreFromDecks() {
      const nextStore = {};
      DECKS.forEach((deck) => {
        if (deck.id === "all") return;
        deck.cards.forEach((card) => {
          if (card._userAdded) {
            if (!nextStore[deck.id]) nextStore[deck.id] = [];
            nextStore[deck.id].push({
              es: card.es,
              en: card.en,
              exampleEs: card.exampleEs,
              exampleEn: card.exampleEn,
              _userAdded: true,
            });
          }
        });
      });
      customCardsStore = nextStore;
      saveCustomCards();
    }

    function getCardId(deckId, index) {
      return deckId + "::" + index;
    }

    function getCardProgress(deckId, index) {
      const id = getCardId(deckId, index);
      return progressMap[id] || { strength: 0, seen: 0, lastSeen: 0 };
    }

    function setCardProgress(deckId, index, update) {
      const id = getCardId(deckId, index);
      const prev = progressMap[id] || { strength: 0, seen: 0, lastSeen: 0 };
      const next = {
        ...prev,
        ...update,
      };
      progressMap[id] = next;
      saveProgress();
      return next;
    }

    function findAllDeckIndexForCard(deckId, index) {
      const allDeck = DECKS.find((d) => d.id === "all");
      if (!allDeck) return -1;
      for (let i = 0; i < allDeck.cards.length; i++) {
        const c = allDeck.cards[i];
        if (c._sourceDeckId === deckId && c._sourceIndex === index) {
          return i;
        }
      }
      return -1;
    }

    function getAggregatedProgressForAllIndex(allIndex) {
      const allDeck = DECKS.find((d) => d.id === "all");
      if (!allDeck || !allDeck.cards[allIndex]) {
        return { correct: 0, wrong: 0 };
      }
      const card = allDeck.cards[allIndex];
      const progAll = getCardProgress("all", allIndex);
      let progSource = { correct: 0, wrong: 0 };
      if (
        card._sourceDeckId &&
        card._sourceDeckId !== "all" &&
        typeof card._sourceIndex === "number"
      ) {
        progSource = getCardProgress(card._sourceDeckId, card._sourceIndex);
      }
      return {
        correct: (progAll.correct || 0) + (progSource.correct || 0),
        wrong: (progAll.wrong || 0) + (progSource.wrong || 0),
      };
    }

    function getAggregatedProgress(deckId, index) {
      const progDeck = getCardProgress(deckId, index);
      const allIndex = findAllDeckIndexForCard(deckId, index);
      let progAll = { correct: 0, wrong: 0 };
      if (allIndex >= 0) {
        const p = getCardProgress("all", allIndex);
        progAll = p;
      }
      return {
        correct: (progDeck.correct || 0) + (progAll.correct || 0),
        wrong: (progDeck.wrong || 0) + (progAll.wrong || 0),
      };
    }

    /******************************************************
     * 3. DOM references
     ******************************************************/
    const deckListEl = document.getElementById("deckList");
    const difficultySelectEl = document.getElementById("difficultySelect");
    const levelSelectEl = document.getElementById("levelSelect");
    const deckDescriptionEl = document.getElementById("deckDescription");
    const statSessionSeenEl = document.getElementById("statSessionSeen");
    const statSessionKnewEl = document.getElementById("statSessionKnew");
    const statSessionLearningEl =
      document.getElementById("statSessionLearning");
    const statTotalWordsEl = document.getElementById("statTotalWords");

    const cardEl = document.getElementById("card");
    const cardDeckLabelEl = document.getElementById("cardDeckLabel");
    const cardStrengthLabelEl = document.getElementById("cardStrengthLabel");
    const cardFrontLabelEl = document.getElementById("cardFrontLabel");
    const cardFrontTextEl = document.getElementById("cardFrontText");
    const cardBackEl = document.getElementById("cardBack");
    const cardBackMainEl = document.getElementById("cardBackMain");
    const cardBackExampleEl = document.getElementById("cardBackExample");
    const cardHintEl = document.getElementById("cardHint");
    const cardIndexBadgeEl = document.getElementById("cardIndexBadge");

    const typedAnswerContainer = document.getElementById(
      "typedAnswerContainer"
    );
    const typedAnswerInput = document.getElementById("typedAnswerInput");
    const typedFeedbackEl = document.getElementById("typedFeedback");

    const deleteCurrentBtn = document.getElementById("deleteCurrentBtn");
const showAnswerBtn = document.getElementById("showAnswerBtn");
const learningBtn = document.getElementById("learningBtn");
const knewItBtn = document.getElementById("knewItBtn");
const skipBtn = document.getElementById("skipBtn");

    const directionToggleEl = document.getElementById("directionToggle");
    const answerModeToggleEl = document.getElementById("answerModeToggle");
    const resetProgressBtn = document.getElementById("resetProgressBtn");
    const sessionInfoEl = document.getElementById("sessionInfo");

    // top icon nav
    const topNavEl = document.getElementById("topNav");
    const panelDecksEl = document.getElementById("panel-decks");
    const panelSessionEl = document.getElementById("panel-session");
    const panelAddEl = document.getElementById("panel-add");
    const panelWordsEl = document.getElementById("panel-words");
    let currentOpenPanelId = "panel-decks";

    // Add-card form
    const addCardFormEl = document.getElementById("addCardForm");
    const addDeckSelectEl = document.getElementById("addDeckSelect");
    const addEsInputEl = document.getElementById("addEs");
    const addEnInputEl = document.getElementById("addEn");
    const addExampleEsInputEl = document.getElementById("addExampleEs");
    const addExampleEnInputEl = document.getElementById("addExampleEn");
    const addFeedbackEl = document.getElementById("addFeedback");
    const toggleExamplesBtn = document.getElementById("toggleExamplesBtn");
    const exampleFieldsEl = document.getElementById("exampleFields");

    // Words view/edit
    const wordsDeckSelectEl = document.getElementById("wordsDeckSelect");
    const wordsListEl = document.getElementById("wordsList");

    // Stats panel
    const statsToggleBtn = document.getElementById("statsToggleBtn");
    const statsPanelEl = document.getElementById("statsPanel");
    const statsKnownCountEl = document.getElementById("statsKnownCount");
    const statsDontKnowCountEl = document.getElementById("statsDontKnowCount");
    const statsStruggleCountEl = document.getElementById("statsStruggleCount");
    const statsDeleteKnownBtn = document.getElementById("statsDeleteKnownBtn");
    const statsExcludeKnownBtn = document.getElementById(
      "statsExcludeKnownBtn"
    );

    // Deck-complete overlay
    const deckCompleteOverlayEl =
      document.getElementById("deckCompleteOverlay");
    const deckCompleteTitleEl = document.getElementById("deckCompleteTitle");
    const deckCompleteTextEl = document.getElementById("deckCompleteText");
    const deckCompleteStruggleBtn = document.getElementById(
      "deckCompleteStruggleBtn"
    );
    const deckCompleteCloseBtn = document.getElementById(
      "deckCompleteCloseBtn"
    );

    /******************************************************
     * 4. Helpers
     ******************************************************/
    function normalizeAnswerString(str) {
      if (!str) return "";
      return str
        .toLowerCase()
        .normalize("NFD") // decompose accents
        .replace(/[\u0300-\u036f]/g, "") // remove diacritics
        .replace(/[¬ø?¬°!.,;:()"'¬´¬ª\-]/g, " ") // remove punctuation
        .replace(/\s+/g, " ")
        .trim();
    }

    function setTopPanel(panelIdOrNull) {
      [panelDecksEl, panelSessionEl, panelAddEl, panelWordsEl].forEach((p) => {
        if (p) p.classList.remove("active");
      });
      topNavEl
        .querySelectorAll(".top-nav-btn")
        .forEach((btn) => btn.classList.remove("active"));

      if (!panelIdOrNull) {
        currentOpenPanelId = null;
        return;
      }

      let panelEl = null;
      if (panelIdOrNull === "panel-decks") panelEl = panelDecksEl;
      else if (panelIdOrNull === "panel-session") panelEl = panelSessionEl;
      else if (panelIdOrNull === "panel-add") panelEl = panelAddEl;
      else if (panelIdOrNull === "panel-words") panelEl = panelWordsEl;

      if (panelEl) panelEl.classList.add("active");
      const key = panelIdOrNull.replace("panel-", "");
      const btn = topNavEl.querySelector(`.top-nav-btn[data-panel="${key}"]`);
      if (btn) btn.classList.add("active");
      currentOpenPanelId = panelIdOrNull;
    }

    function computeGlobalStats() {
      const allDeck = DECKS.find((d) => d.id === "all");
      if (!allDeck) return { known: 0, dontKnow: 0, struggle: 0 };
      let known = 0;
      let dontKnow = 0;
      let struggle = 0;
      allDeck.cards.forEach((card, idx) => {
        const agg = getAggregatedProgressForAllIndex(idx);
        const c = agg.correct || 0;
        const w = agg.wrong || 0;
        if (c === 0 && w === 0) {
          dontKnow++;
        } else if (c === 0 && w > 0) {
          // seen but never correct
          dontKnow++;
        } else if (c > 0 && w === 0) {
          known++;
        } else if (c > 0 && w > 0) {
          struggle++;
        }
      });
      return { known, dontKnow, struggle };
    }

    function launchConfetti() {
      const container = document.createElement("div");
      container.className = "confetti-container";
      const colors = ["#22c55e", "#38bdf8", "#facc15", "#f97316", "#a855f7"];

      for (let i = 0; i < 120; i++) {
        const piece = document.createElement("div");
        piece.className = "confetti-piece";
        piece.style.left = Math.random() * 100 + "vw";
        piece.style.top = Math.random() * -20 + "vh";
        piece.style.backgroundColor =
          colors[Math.floor(Math.random() * colors.length)];
        piece.style.animationDelay = Math.random() * 0.4 + "s";
        piece.style.transform = `rotate(${Math.random() * 360}deg)`;
        container.appendChild(piece);
      }

      document.body.appendChild(container);
      setTimeout(() => {
        container.remove();
      }, 3200);
    }

    function handleDeckCompleted(deckId) {
      const deck = DECKS.find((d) => d.id === deckId);
      if (!deck) return;
      lastCompletedDeckId = deckId;

      const allDeck = DECKS.find((d) => d.id === "all");
      let struggleCount = 0;
      if (allDeck) {
        allDeck.cards.forEach((card, idx) => {
          if (card._sourceDeckId !== deckId) return;
          const agg = getAggregatedProgressForAllIndex(idx);
          if ((agg.wrong || 0) > 0) struggleCount++;
        });
      }

      deckCompleteTitleEl.textContent = "üéâ Congrats!";
      deckCompleteTextEl.textContent =
        struggleCount > 0
          ? `You went through every card in "${deck.name}". Want to focus on the ${struggleCount} words you struggled with?`
          : `You went through every card in "${deck.name}" without really struggling. Nice work!`;

      deckCompleteStruggleBtn.style.display =
        struggleCount > 0 ? "inline-flex" : "none";

      deckCompleteOverlayEl.style.display = "flex";
      launchConfetti();
    }

    /******************************************************
     * 5. UI
    function deckMatchesCurrentFilter(deck) {
      if (!deck || deck.id === "all") return false;
      if (currentDifficultyId && deck.difficultyId && deck.difficultyId !== currentDifficultyId) {
        return false;
      }
      if (
        typeof deck.levelIndex === "number" &&
        deck.levelIndex !== currentLevelIndex
      ) {
        return false;
      }
      return true;
    }

    function populateDifficultySelect() {
      if (!difficultySelectEl) return;
      difficultySelectEl.innerHTML = "";
      if (!DIFFICULTIES || !DIFFICULTIES.length) return;
      DIFFICULTIES.forEach((diff) => {
        const opt = document.createElement("option");
        opt.value = diff.id;
        opt.textContent = diff.label || diff.id;
        difficultySelectEl.appendChild(opt);
      });
      if (!currentDifficultyId) {
        currentDifficultyId = DIFFICULTIES[0].id;
      }
      difficultySelectEl.value = currentDifficultyId;
    }

    function populateLevelSelect() {
      if (!levelSelectEl) return;
      levelSelectEl.innerHTML = "";
      const levels = [1, 2, 3];
      levels.forEach((lvl) => {
        const opt = document.createElement("option");
        opt.value = String(lvl);
        opt.textContent = "Level " + lvl;
        levelSelectEl.appendChild(opt);
      });
      levelSelectEl.value = String(currentLevelIndex || 1);
    }

    function selectFirstDeckForCurrentFilter() {
      const candidate = DECKS.find((d) => deckMatchesCurrentFilter(d));
      if (candidate) {
        currentDeckId = candidate.id;
        sessionSeenByDeck[currentDeckId] = new Set();
        sessionInfoEl.textContent =
          "New difficulty/level selected ‚Äì now training on " + candidate.name + ".";
        goToNextCard();
      } else {
        currentDeckId = "all";
        sessionSeenByDeck[currentDeckId] = new Set();
        sessionInfoEl.textContent =
          "No decks found for this difficulty/level. Try another combination.";
        goToNextCard();
      }
    }

    function onDifficultyChange() {
      if (!difficultySelectEl) return;
      currentDifficultyId = difficultySelectEl.value;
      lastPlayedDifficultyId = currentDifficultyId;
      renderDeckList();
      populateAddDeckSelect();
      populateWordsDeckSelect();
      renderWordsList();
      selectFirstDeckForCurrentFilter();
    }

    function onLevelChange() {
      if (!levelSelectEl) return;
      const lvl = parseInt(levelSelectEl.value, 10);
      currentLevelIndex = Number.isNaN(lvl) ? 1 : lvl;
      lastPlayedLevelIndex = currentLevelIndex;
      renderDeckList();
      populateAddDeckSelect();
      populateWordsDeckSelect();
      renderWordsList();
      selectFirstDeckForCurrentFilter();
    }

 helpers
     ******************************************************/
    function renderDeckList() {
      if (!deckListEl) return;
      deckListEl.innerHTML = "";
      if (!DECKS || !DECKS.length) return;

      const filtered = DECKS.filter((deck) => deckMatchesCurrentFilter(deck));
      if (!filtered.length) {
        const empty = document.createElement("div");
        empty.className = "words-empty";
        empty.textContent = "No decks for this difficulty/level yet.";
        deckListEl.appendChild(empty);
        return;
      }

      filtered.forEach((deck) => {
        if (!deck) return;
        const item = document.createElement("div");
        item.className = "deck-item";
        if (deck.id === currentDeckId) {
          item.classList.add("active");
        }
        item.dataset.deckId = deck.id;

        const name = document.createElement("div");
        name.className = "deck-name";
        name.textContent = deck.name;

        const meta = document.createElement("div");
        meta.className = "deck-meta";

        const totalCards = deck.cards ? deck.cards.length : 0;
        const levelLabel =
          typeof deck.levelIndex === "number" && deck.levelIndex > 0
            ? ` ¬∑ L${deck.levelIndex}`
            : "";
        meta.textContent = `${totalCards} words${levelLabel}`;

        item.appendChild(name);
        item.appendChild(meta);
        deckListEl.appendChild(item);
      });
    }

    function populateAddDeckSelect() {
      if (!addDeckSelectEl) return;
      addDeckSelectEl.innerHTML = "";
      if (!DECKS || !DECKS.length) return;

      let defaultDeckId = null;
      DECKS.forEach((deck) => {
        if (!deck || deck.id === "all") return;
        const opt = document.createElement("option");
        opt.value = deck.id;
        opt.textContent = deck.name;
        addDeckSelectEl.appendChild(opt);

        if (
          !defaultDeckId &&
          deck.difficultyId === lastPlayedDifficultyId &&
          deck.levelIndex === lastPlayedLevelIndex
        ) {
          defaultDeckId = deck.id;
        }
      });

      if (currentDeckId && currentDeckId !== "all") {
        addDeckSelectEl.value = currentDeckId;
      } else if (defaultDeckId) {
        addDeckSelectEl.value = defaultDeckId;
      } else if (addDeckSelectEl.options.length) {
        addDeckSelectEl.value = addDeckSelectEl.options[0].value;
      }
    }

    function populateWordsDeckSelect() {
      if (!wordsDeckSelectEl) return;
      const previous = wordsDeckSelectEl.value;
      wordsDeckSelectEl.innerHTML = "";

      const allOpt = document.createElement("option");
      allOpt.value = "*all";
      allOpt.textContent = "All decks";
      wordsDeckSelectEl.appendChild(allOpt);

      DECKS.forEach((deck) => {
        if (deck.id === "all") return;
        const opt = document.createElement("option");
        opt.value = deck.id;
        opt.textContent = deck.name;
        wordsDeckSelectEl.appendChild(opt);
      });

      if (previous && [...wordsDeckSelectEl.options].some((o) => o.value === previous)) {
        wordsDeckSelectEl.value = previous;
      } else if (currentDeckId !== "all") {
        wordsDeckSelectEl.value = currentDeckId;
      } else {
        wordsDeckSelectEl.value = "*all";
      }
    }

    function createWordRow(row) {
      const { deckId, index, card } = row;
      const deck = DECKS.find((d) => d.id === deckId);
      const rowEl = document.createElement("div");
      rowEl.className = "word-row";
      rowEl.dataset.deckId = deckId;
      rowEl.dataset.index = index;

      const main = document.createElement("div");
      main.className = "word-row-main";

      const line1 = document.createElement("div");
      line1.className = "word-row-line";
      const labelEs = document.createElement("span");
      labelEs.className = "label";
      labelEs.textContent = "ES";
      const inputEs = document.createElement("input");
      inputEs.className = "word-input";
      inputEs.type = "text";
      inputEs.value = card.es || "";
      inputEs.dataset.field = "es";
      line1.appendChild(labelEs);
      line1.appendChild(inputEs);

      const line2 = document.createElement("div");
      line2.className = "word-row-line";
      const labelEn = document.createElement("span");
      labelEn.className = "label";
      labelEn.textContent = "EN";
      const inputEn = document.createElement("input");
      inputEn.className = "word-input";
      inputEn.type = "text";
      inputEn.value = card.en || "";
      inputEn.dataset.field = "en";
      line2.appendChild(labelEn);
      line2.appendChild(inputEn);

      const deckLine = document.createElement("div");
      deckLine.className = "word-row-deck";
      deckLine.textContent = deck ? deck.name : deckId;

      main.appendChild(line1);
      main.appendChild(line2);
      main.appendChild(deckLine);

      const actions = document.createElement("div");
      actions.className = "word-row-actions";
      const deleteBtn = document.createElement("button");
      deleteBtn.className = "btn btn-danger btn-xs word-delete-btn";
      deleteBtn.textContent = "üóë";
      actions.appendChild(deleteBtn);

      rowEl.appendChild(main);
      rowEl.appendChild(actions);
      return rowEl;
    }

    function renderWordsList() {
      if (!wordsListEl || !wordsDeckSelectEl) return;
      const selected = wordsDeckSelectEl.value || "*all";
      wordsListEl.innerHTML = "";

      const rows = [];
      if (selected === "*all") {
        DECKS.forEach((deck) => {
          if (deck.id === "all") return;
          deck.cards.forEach((card, index) => {
            rows.push({ deckId: deck.id, index, card });
          });
        });
      } else {
        const deck = DECKS.find((d) => d.id === selected);
        if (deck) {
          deck.cards.forEach((card, index) => {
            rows.push({ deckId: selected, index, card });
          });
        }
      }

      if (!rows.length) {
        const empty = document.createElement("div");
        empty.className = "words-empty";
        empty.textContent = "No words yet in this view.";
        wordsListEl.appendChild(empty);
        return;
      }

      rows.forEach((row) => {
        wordsListEl.appendChild(createWordRow(row));
      });
    }

    function updateDeckDescription() {
      const deck = DECKS.find((d) => d.id === currentDeckId);
      deckDescriptionEl.textContent = deck
        ? deck.description
        : "Pick a deck above to start practicing.";
    }

    function updateStatsUI() {
      const allDeck = DECKS.find((d) => d.id === "all");
      statTotalWordsEl.textContent = allDeck ? allDeck.cards.length : 0;
      statSessionSeenEl.textContent = sessionStats.seen;
      statSessionKnewEl.textContent = sessionStats.knew;
      statSessionLearningEl.textContent = sessionStats.learning;

      if (statsKnownCountEl && statsDontKnowCountEl && statsStruggleCountEl) {
        const global = computeGlobalStats();
        statsKnownCountEl.textContent = global.known;
        statsDontKnowCountEl.textContent = global.dontKnow;
        statsStruggleCountEl.textContent = global.struggle;
      }
    }

    function updateCardStrengthLabel(cardProgress) {
      if (!cardProgress) {
        cardStrengthLabelEl.textContent = "New word";
        return;
      }
      const s = cardProgress.strength || 0;
      if (s <= 0) {
        cardStrengthLabelEl.textContent = "New word";
      } else if (s === 1) {
        cardStrengthLabelEl.textContent = "Learning ¬∑ ‚òÜ";
      } else if (s === 2) {
        cardStrengthLabelEl.textContent = "Getting stronger ¬∑ ‚òÜ‚òÜ";
      } else {
        cardStrengthLabelEl.textContent = "Strong word ¬∑ ‚òÜ‚òÜ‚òÜ";
      }
    }

    function renderCard() {
      const deck = DECKS.find((d) => d.id === currentDeckId);

      if (!deck || !deck.cards.length) {
        cardFrontTextEl.textContent = "No words in this deck yet.";
        cardDeckLabelEl.textContent = deck ? deck.name : "No deck";
        cardBackEl.style.display = "none";
        cardHintEl.textContent =
          "Add words in the Add word panel or pick another deck.";
        showAnswerBtn.disabled = true;
        learningBtn.disabled = true;
        knewItBtn.disabled = true;
        skipBtn.disabled = true;
        cardIndexBadgeEl.textContent = "‚Äî";
        typedAnswerContainer.style.display = "none";
        typedFeedbackEl.textContent = "";
        updateCardStrengthLabel(null);
        return;
      }

      if (!currentCardRef) {
        const hasFilter =
          excludeKnownFromSession || currentSessionFilter !== "all";
        cardFrontTextEl.textContent = hasFilter
          ? "No cards match the current filter."
          : "Choose a deck to begin";
        cardDeckLabelEl.textContent = deck.name;
        cardBackEl.style.display = "none";
        cardHintEl.textContent = hasFilter
          ? "Adjust your stats filters below or pick another deck to keep practicing."
          : "Pick a deck from the Decks panel above to start your session.";
        showAnswerBtn.disabled = true;
        learningBtn.disabled = true;
        knewItBtn.disabled = true;
        skipBtn.disabled = true;
        cardIndexBadgeEl.textContent = "‚Äî";
        typedAnswerContainer.style.display = "none";
        typedFeedbackEl.textContent = "";
        updateCardStrengthLabel(null);
        return;
      }

      const { deckId, index } = currentCardRef;
      const currentDeck = DECKS.find((d) => d.id === deckId);
      const card = currentDeck.cards[index];

      cardDeckLabelEl.textContent =
        deckId === "all" ? "All decks" : currentDeck.name;

      const frontIsSpanish = currentDirection === "es-en";
      cardFrontLabelEl.textContent = frontIsSpanish ? "Spanish" : "English";
      const frontText = frontIsSpanish ? card.es : card.en;
      const backText = frontIsSpanish ? card.en : card.es;

      cardFrontTextEl.textContent = frontText;
      cardBackMainEl.textContent = backText;

      let exampleHtml = "";
      if (card.exampleEs || card.exampleEn) {
        if (frontIsSpanish) {
          if (card.exampleEs) {
            exampleHtml +=
              "<span><strong>ES:</strong> " + card.exampleEs + "</span>";
          }
          if (card.exampleEn) {
            exampleHtml +=
              "<span><strong>EN:</strong> " + card.exampleEn + "</span>";
          }
        } else {
          if (card.exampleEn) {
            exampleHtml +=
              "<span><strong>EN:</strong> " + card.exampleEn + "</span>";
          }
          if (card.exampleEs) {
            exampleHtml +=
              "<span><strong>ES:</strong> " + card.exampleEs + "</span>";
          }
        }
      }
      cardBackExampleEl.innerHTML = exampleHtml;

      const progress = getCardProgress(deckId, index);
      updateCardStrengthLabel(progress);

      const totalInDeck = deck.cards.length;
      cardIndexBadgeEl.textContent = `Card ${index + 1} of ${totalInDeck}`;

      if (currentAnswerMode === "reveal") {
  typedAnswerContainer.style.display = "none";
  typedFeedbackEl.textContent = "";
  if (typedAnswerInput) typedAnswerInput.value = "";

  cardBackEl.style.display = currentRevealed ? "block" : "none";

  // Hide "Show answer" once revealed
  showAnswerBtn.disabled = currentRevealed;
  showAnswerBtn.style.display = currentRevealed ? "none" : "inline-flex";

  learningBtn.disabled = !currentRevealed;
  knewItBtn.disabled = !currentRevealed;

  learningBtn.style.display = currentRevealed ? "inline-flex" : "none";
  knewItBtn.style.display = currentRevealed ? "inline-flex" : "none";

  showAnswerBtn.textContent = "üëÄ Show answer";

  cardHintEl.textContent = currentRevealed
    ? "Mark if you knew it or not."
    : "Try to recall it, then show the answer.";
} else {
  // TYPE MODE
  typedAnswerContainer.style.display = "flex";
  cardBackEl.style.display = typeAnswerChecked ? "block" : "none";
  learningBtn.style.display = "none";
  knewItBtn.style.display = "none";

  showAnswerBtn.disabled = false;
  showAnswerBtn.style.display = "inline-flex";
  showAnswerBtn.textContent = typeAnswerChecked
    ? "Next word"
    : "‚èé Check answer";

        cardHintEl.textContent = typeAnswerChecked
          ? 'Press "Next word" to continue, or use Skip to move on without marking.'
          : 'Type the translation and press Enter or "Check answer".';
      }

      skipBtn.disabled = false;
    }

    /******************************************************
     * 6. Card selection logic (simple spaced repetition)
     ******************************************************/
    function chooseNextCard() {
      const deck = DECKS.find((d) => d.id === currentDeckId);
      if (!deck || !deck.cards.length) {
        currentCardRef = null;
        return;
      }

      const now = Date.now();
      const candidates = [];

        deck.cards.forEach((card, idx) => {
    // Skip cards that were deleted in this session
    const deletedSet = deletedInSession[currentDeckId];
    if (deletedSet && deletedSet.has(idx)) {
      return;
    }

    const prog = getCardProgress(currentDeckId, idx);
    const agg = getAggregatedProgress(currentDeckId, idx);

    if (currentSessionFilter === "struggle" && (agg.wrong || 0) <= 0) {
      return;
    }
    if (
      excludeKnownFromSession &&
      (agg.correct || 0) > 0 &&
      (agg.wrong || 0) === 0
    ) {
      return;
    }

        const ageMinutes =
          prog.lastSeen > 0 ? (now - prog.lastSeen) / 60000 : 9999;
        let weight = 1 + Math.max(0, 3 - (prog.strength || 0)) * 2;

        if (currentMode === "focus") {
          if ((prog.strength || 0) <= 1) {
            weight *= 2.2;
          } else {
            weight *= 0.8;
          }
        }

        if (ageMinutes < 1) {
          weight *= 0.4;
        }

        candidates.push({
          deckId: currentDeckId,
          index: idx,
          weight,
        });
      });

      if (!candidates.length) {
        currentCardRef = null;
        return;
      }

      const totalWeight = candidates.reduce((sum, c) => sum + c.weight, 0);
      let rnd = Math.random() * totalWeight;
      let chosen = candidates[0];
      for (const c of candidates) {
        rnd -= c.weight;
        if (rnd <= 0) {
          chosen = c;
          break;
        }
      }
      currentCardRef = chosen;
    }

    function goToNextCard() {
      currentRevealed = false;
      typeAnswerChecked = false;
      lastTypeWasCorrect = null;
      if (typedAnswerInput) typedAnswerInput.value = "";
      typedFeedbackEl.textContent = "";
      chooseNextCard();
      renderCard();

      if (currentAnswerMode === "type" && typedAnswerInput) {
        setTimeout(() => typedAnswerInput.focus(), 0);
      }
    }

    /******************************************************
     * 7. Event handlers
     ******************************************************/
    function onDeckClick(e) {
      const item = e.target.closest(".deck-item");
      if (!item) return;
      const deckId = item.dataset.deckId;
      if (!deckId || deckId === currentDeckId) return;
      currentDeckId = deckId;

      const deck = DECKS.find((d) => d.id === deckId);
      if (deck) {
        if (deck.difficultyId && deck.difficultyId !== "*all") {
          currentDifficultyId = deck.difficultyId;
          lastPlayedDifficultyId = deck.difficultyId;
          if (difficultySelectEl) {
            difficultySelectEl.value = deck.difficultyId;
          }
        }
        if (typeof deck.levelIndex === "number" && deck.levelIndex > 0) {
          currentLevelIndex = deck.levelIndex;
          lastPlayedLevelIndex = deck.levelIndex;
          if (levelSelectEl) {
            levelSelectEl.value = String(deck.levelIndex);
          }
        }
      }

      deckListEl
        .querySelectorAll(".deck-item")
        .forEach((el) => el.classList.remove("active"));
      item.classList.add("active");
      updateDeckDescription();
      populateAddDeckSelect();
      populateWordsDeckSelect();
      renderWordsList();
      currentSessionFilter = "all";
      sessionSeenByDeck[currentDeckId] = new Set();
      sessionInfoEl.textContent =
        "New deck selected. The app will keep mixing words and show the ones you struggle with more often.";
      goToNextCard();
    }

    function onShowAnswer() {
      if (!currentCardRef) return;
      if (currentAnswerMode === "reveal") {
        currentRevealed = true;
        renderCard();
      } else {
        onAnswerButtonClick();
      }
    }

    function onCheckTypedAnswer() {
      if (!currentCardRef) return;
      const { deckId, index } = currentCardRef;
      const currentDeck = DECKS.find((d) => d.id === deckId);
      const card = currentDeck.cards[index];

      const frontIsSpanish = currentDirection === "es-en";
      const targetRaw = frontIsSpanish ? card.en : card.es;
      const userRaw = typedAnswerInput.value || "";

      const userNorm = normalizeAnswerString(userRaw);
      const targetNorm = normalizeAnswerString(targetRaw);

      if (!userNorm) {
        typedFeedbackEl.textContent = "Type something first.";
        typedFeedbackEl.style.color = "var(--text-muted)";
        return;
      }

      const isCorrect = userNorm === targetNorm;

      if (isCorrect) {
        typedFeedbackEl.textContent = "Correct!";
        typedFeedbackEl.style.color = "#bbf7d0";
      } else {
        typedFeedbackEl.textContent = `Almost. Correct: ${targetRaw}`;
        typedFeedbackEl.style.color = "#fecaca";
      }

      cardBackEl.style.display = "block";
      typeAnswerChecked = true;
      lastTypeWasCorrect = isCorrect;
      showAnswerBtn.textContent = "Next word";
      cardHintEl.textContent = 'Press "Next word" to go to the next card.';
    }

    function onTypeNext() {
      if (!currentCardRef) return;
      if (!typeAnswerChecked || lastTypeWasCorrect === null) {
        goToNextCard();
        return;
      }
      onMark(lastTypeWasCorrect);
    }

    function onAnswerButtonClick() {
      if (currentAnswerMode === "reveal") {
        onShowAnswer();
      } else {
        if (!typeAnswerChecked) {
          onCheckTypedAnswer();
        } else {
          onTypeNext();
        }
      }
    }

    function onMark(known) {
      if (!currentCardRef) return;

      const { deckId, index } = currentCardRef;
      const prev = getCardProgress(deckId, index);
      const now = Date.now();

      let newStrength = prev.strength || 0;
      let correct = prev.correct || 0;
      let wrong = prev.wrong || 0;
      let firstAnswerCorrect =
        typeof prev.firstAnswerCorrect === "boolean"
          ? prev.firstAnswerCorrect
          : null;

      if (known) {
        if (newStrength < 3) newStrength += 1;
        correct += 1;
        if (prev.seen === 0 || prev.seen == null) {
          firstAnswerCorrect = true;
        }
      } else {
        newStrength = Math.max(0, newStrength - 1);
        wrong += 1;
        if (prev.seen === 0 || prev.seen == null) {
          firstAnswerCorrect = false;
        }
      }

      const updated = setCardProgress(deckId, index, {
        strength: newStrength,
        seen: (prev.seen || 0) + 1,
        lastSeen: now,
        correct,
        wrong,
        firstAnswerCorrect,
      });

      sessionStats.seen += 1;
      if (known) {
        sessionStats.knew += 1;
      } else {
        sessionStats.learning += 1;
      }
      updateStatsUI();
      updateCardStrengthLabel(updated);

      // track per-deck seen for deck completion
      if (!sessionSeenByDeck[deckId]) {
        sessionSeenByDeck[deckId] = new Set();
      }
      sessionSeenByDeck[deckId].add(getCardId(deckId, index));

      const deck = DECKS.find((d) => d.id === deckId);
      if (
        deck &&
        !deckCompletionShown[deckId] &&
        sessionSeenByDeck[deckId].size >= deck.cards.length &&
        deck.cards.length > 0
      ) {
        deckCompletionShown[deckId] = true;
        handleDeckCompleted(deckId);
      }

      goToNextCard();
    }

    function onSkip() {
      if (!currentCardRef) return;
      goToNextCard();
    }
    
    function onDeleteCurrentCard() {
  if (!currentCardRef) return;

  const { deckId, index } = currentCardRef;
  const deck = DECKS.find((d) => d.id === deckId);
  if (!deck) return;

  const ok = confirm(
    "Remove this card from this session? You won‚Äôt see it again until you reload the app."
  );
  if (!ok) return;

  // Mark deleted for the current deck
  markCardDeletedForSession(deckId, index);

  // If we‚Äôre in the 'all' deck, also hide it from its original deck
  if (deckId === "all") {
    const cardInAll = deck.cards[index];
    if (
      cardInAll &&
      cardInAll._sourceDeckId &&
      typeof cardInAll._sourceIndex === "number"
    ) {
      markCardDeletedForSession(cardInAll._sourceDeckId, cardInAll._sourceIndex);
    }
  }

  // Move on to the next card
  currentCardRef = null;
  goToNextCard();
}


    function onDirectionToggle(e) {
      const btn = e.target.closest("button");
      if (!btn) return;
      const dir = btn.dataset.direction;
      if (!dir || dir === currentDirection) return;
      currentDirection = dir;

      directionToggleEl
        .querySelectorAll("button")
        .forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");

      if (currentCardRef) {
        renderCard();
      }
    }

    function onAnswerModeToggle(e) {
      const btn = e.target.closest("button");
      if (!btn) return;
      const mode = btn.dataset["answerMode"];
      if (!mode || mode === currentAnswerMode) return;
      currentAnswerMode = mode;

      answerModeToggleEl
        .querySelectorAll("button")
        .forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");

      typeAnswerChecked = false;
      lastTypeWasCorrect = null;
      if (typedAnswerInput) typedAnswerInput.value = "";
      typedFeedbackEl.textContent = "";

      if (currentAnswerMode === "type") {
        sessionInfoEl.textContent =
          "Type mode: you type the translation. Accents, case, and punctuation don‚Äôt matter.";
      } else {
        sessionInfoEl.textContent =
          "Reveal mode: you see the answer and mark if you knew it.";
      }

      currentRevealed = false;
      renderCard();
      if (currentAnswerMode === "type" && typedAnswerInput) {
        setTimeout(() => typedAnswerInput.focus(), 0);
      }
    }

    function onResetProgress() {
      if (
        confirm(
          "Reset all learning progress? This will forget which words you already know."
        )
      ) {
        resetProgress();
        sessionInfoEl.textContent =
          "Progress reset. All words are new again.";
        sessionSeenByDeck = {};
        deckCompletionShown = {};
        goToNextCard();
      }
    }

    function onKeyDown(e) {
  const target = e.target;
  const tag = target && target.tagName;
  const isFormField =
    tag === "INPUT" ||
    tag === "TEXTAREA" ||
    tag === "SELECT" ||
    (target && target.isContentEditable);

  // If we are typing in any input/textarea/select that is NOT the main
  // typed-answer field, do NOT hijack the spacebar or other shortcuts.
  if (isFormField && target !== typedAnswerInput) {
    return;
  }

  if (!currentCardRef) return;

  if (currentAnswerMode === "type") {
    if (e.key === "Enter") {
      e.preventDefault();
      if (!typeAnswerChecked) {
        onCheckTypedAnswer();
      } else {
        onTypeNext();
      }
    } else if (e.key === "ArrowRight") {
      onSkip();
    }
    return;
  }

  if (e.code === "Space" || e.key === " ") {
    e.preventDefault();
    if (!currentRevealed) {
      onShowAnswer();
    } else {
      onMark(true);
    }
  } else if (e.key === "1") {
    onMark(false);
  } else if (e.key === "2") {
    onMark(true);
  } else if (e.key === "ArrowRight") {
    onSkip();
  }
}


        function onAddCardSubmit(e) {
      e.preventDefault();
      const es = (addEsInputEl.value || "").trim();
      const en = (addEnInputEl.value || "").trim();
      const exampleEs = (addExampleEsInputEl.value || "").trim();
      const exampleEn = (addExampleEnInputEl.value || "").trim();
      let deckId = addDeckSelectEl.value;

      if (!es || !en) {
        addFeedbackEl.textContent =
          "Please fill in both Spanish and English.";
        addFeedbackEl.style.color = "#fecaca";
        return;
      }

      if (!deckId || deckId === "all") {
        deckId = currentDeckId !== "all" ? currentDeckId : "core-verbs";
      }

      const deck = DECKS.find((d) => d.id === deckId);
      if (!deck) {
        addFeedbackEl.textContent = "Unknown deck. Try again.";
        addFeedbackEl.style.color = "#fecaca";
        return;
      }

      const card = {
        es,
        en,
        exampleEs: exampleEs || undefined,
        exampleEn: exampleEn || undefined,
        _userAdded: true,
      };

      deck.cards.push(card);
      syncCustomStoreFromDecks();
      rebuildAllDeck();

      addEsInputEl.value = "";
      addEnInputEl.value = "";
      addExampleEsInputEl.value = "";
      addExampleEnInputEl.value = "";
      addEsInputEl.focus();

      addFeedbackEl.textContent = `Added to "${deck.name}".`;
      addFeedbackEl.style.color = "#bbf7d0";

      updateStatsUI();
      renderDeckList();
      populateWordsDeckSelect();
      renderWordsList();

      if (!currentCardRef || currentDeckId === deckId) {
        currentDeckId = deckId;
        goToNextCard();
      }
    }

    function onTopNavClick(e) {
      const btn = e.target.closest(".top-nav-btn");
      if (!btn) return;
      const key = btn.dataset.panel;
      const panelId = "panel-" + key;

      if (currentOpenPanelId === panelId) {
        setTopPanel(null);
      } else {
        setTopPanel(panelId);
        if (panelId === "panel-words") {
          renderWordsList();
        }
      }
    }

    function onWordsDeckChange() {
      renderWordsList();
    }

    function onWordsListInput(e) {
      const input = e.target.closest(".word-input");
      if (!input) return;
      const row = e.target.closest(".word-row");
      if (!row) return;

      const deckId = row.dataset.deckId;
      const index = parseInt(row.dataset.index, 10);
      const deck = DECKS.find((d) => d.id === deckId);
      if (!deck || !deck.cards[index]) return;

      const field = input.dataset.field;
      if (field !== "es" && field !== "en") return;

      deck.cards[index][field] = input.value;
      syncCustomStoreFromDecks();
      rebuildAllDeck();
      updateStatsUI();

      if (
        currentCardRef &&
        currentCardRef.deckId === deckId &&
        currentCardRef.index === index
      ) {
        renderCard();
      }
    }

    function onWordsListClick(e) {
      const deleteBtn = e.target.closest(".word-delete-btn");
      if (!deleteBtn) return;

      const row = deleteBtn.closest(".word-row");
      if (!row) return;

      const deckId = row.dataset.deckId;
      const index = parseInt(row.dataset.index, 10);
      const deck = DECKS.find((d) => d.id === deckId);
      if (!deck || !deck.cards[index]) return;

      const card = deck.cards[index];
      const label = card.es || card.en || "this word";

      const ok = confirm(
        `Delete "${label}" from the "${deck.name}" deck?`
      );
      if (!ok) return;

      deck.cards.splice(index, 1);
      syncCustomStoreFromDecks();
      rebuildAllDeck();
      updateStatsUI();
      renderDeckList();
      renderWordsList();

      if (currentDeckId === deckId) {
        currentCardRef = null;
        goToNextCard();
      }
    }

    function deleteKnownWords() {
      const allDeck = DECKS.find((d) => d.id === "all");
      if (!allDeck) return;

      const toDeleteByDeck = {};
      allDeck.cards.forEach((card, idx) => {
        const agg = getAggregatedProgressForAllIndex(idx);
        const c = agg.correct || 0;
        const w = agg.wrong || 0;
        const isKnown = c > 0 && w === 0;

        if (!isKnown) return;
        const srcDeckId = card._sourceDeckId;
        const srcIndex = card._sourceIndex;
        if (!srcDeckId || srcDeckId === "all") return;
        if (typeof srcIndex !== "number") return;

        if (!toDeleteByDeck[srcDeckId]) {
          toDeleteByDeck[srcDeckId] = new Set();
        }
        toDeleteByDeck[srcDeckId].add(srcIndex);
      });

      DECKS.forEach((deck) => {
        if (deck.id === "all") return;
        const marks = toDeleteByDeck[deck.id];
        if (!marks || !marks.size) return;
        deck.cards = deck.cards.filter((_, idx) => !marks.has(idx));
      });

      syncCustomStoreFromDecks();
      rebuildAllDeck();

      // Easiest + safest: reset learning after pruning
      resetProgress();
      sessionSeenByDeck = {};
      deckCompletionShown = {};

      renderDeckList();
      populateWordsDeckSelect();
      renderWordsList();
      updateStatsUI();

      currentCardRef = null;
      goToNextCard();
    }

    function onStatsToggle() {
      if (!statsPanelEl) return;
      const visible = statsPanelEl.style.display === "block";
      statsPanelEl.style.display = visible ? "none" : "block";
      statsToggleBtn.textContent = visible ? "üìä Stats" : "üìä Hide stats";
      if (!visible) {
        updateStatsUI();
      }
    }

    function onStatsDeleteKnown() {
      const ok = confirm(
        "Delete all words you already know (only correct answers, never wrong) from all decks? This also resets your learning progress."
      );
      if (!ok) return;
      deleteKnownWords();
      sessionInfoEl.textContent =
        "Known words removed and progress reset. Fresh start with the remaining words.";
    }

    function onStatsExcludeKnown() {
      excludeKnownFromSession = !excludeKnownFromSession;
      if (excludeKnownFromSession) {
        statsExcludeKnownBtn.textContent =
          "‚úÖ Excluding known words this session";
      } else {
        statsExcludeKnownBtn.textContent =
          "üö´ Exclude known words this session";
      }
      currentCardRef = null;
      goToNextCard();
    }

    function onDeckCompletePracticeStruggle() {
      const deckId = lastCompletedDeckId;
      if (!deckId) return;
      const deck = DECKS.find((d) => d.id === deckId);
      currentDeckId = deckId;
      currentSessionFilter = "struggle";
      excludeKnownFromSession = false;

      renderDeckList();
      updateDeckDescription();
      deckCompleteOverlayEl.style.display = "none";

      sessionSeenByDeck[deckId] = new Set();
      sessionInfoEl.textContent = deck
        ? `Now focusing only on the words you struggled with in "${deck.name}".`
        : "Now focusing only on the words you struggled with in this deck.";

      currentCardRef = null;
      goToNextCard();
    }

    function onDeckCompleteClose() {
      deckCompleteOverlayEl.style.display = "none";
      currentSessionFilter = "all";
      sessionInfoEl.textContent =
        "Nice work ‚Äì you‚Äôve seen every word in this deck. Keep going or switch decks.";
    }

    function onToggleExamples() {
      if (!exampleFieldsEl) return;
      const isVisible = exampleFieldsEl.style.display === "grid" ||
        exampleFieldsEl.style.display === "block";
      if (isVisible) {
        exampleFieldsEl.style.display = "none";
        toggleExamplesBtn.textContent = "‚ûï Add examples";
      } else {
        // grid on desktop, block on mobile; CSS will handle mobile @media
        exampleFieldsEl.style.display = "grid";
        toggleExamplesBtn.textContent = "‚ûñ Hide examples";
      }
    }

    /******************************************************
     * 8. Init
     ******************************************************/
    
    async function init() {
      loadProgress();
      await loadDecksFromJson();
      loadCustomCards();
      rebuildAllDeck();

      populateDifficultySelect();
      populateLevelSelect();
      renderDeckList();
      updateDeckDescription();
      populateAddDeckSelect();
      populateWordsDeckSelect();
      renderWordsList();
      updateStatsUI();

      // Events
      if (deckListEl) {
        deckListEl.addEventListener("click", onDeckClick);
      }
      if (showAnswerBtn) {
        showAnswerBtn.addEventListener("click", onAnswerButtonClick);
      }
      if (learningBtn) {
        learningBtn.addEventListener("click", () => onMark(false));
      }
      if (knewItBtn) {
        knewItBtn.addEventListener("click", () => onMark(true));
      }
      if (skipBtn) {
        skipBtn.addEventListener("click", onSkip);
      }
      if (deleteCurrentBtn) {
        deleteCurrentBtn.addEventListener("click", onDeleteCurrentCard);
      }

      if (directionToggleEl) {
        directionToggleEl.addEventListener("click", onDirectionToggle);
      }
      if (answerModeToggleEl) {
        answerModeToggleEl.addEventListener("click", onAnswerModeToggle);
      }
      if (resetProgressBtn) {
        resetProgressBtn.addEventListener("click", onResetProgress);
      }

      document.addEventListener("keydown", onKeyDown);

      if (addCardFormEl) {
        addCardFormEl.addEventListener("submit", onAddCardSubmit);
      }
      if (toggleExamplesBtn) {
        toggleExamplesBtn.addEventListener("click", onToggleExamples);
      }

      if (difficultySelectEl) {
        difficultySelectEl.addEventListener("change", onDifficultyChange);
      }
      if (levelSelectEl) {
        levelSelectEl.addEventListener("change", onLevelChange);
      }

      if (topNavEl) {
        topNavEl.addEventListener("click", onTopNavClick);
      }

      if (wordsDeckSelectEl) {
        wordsDeckSelectEl.addEventListener("change", onWordsDeckChange);
      }
      if (wordsListEl) {
        wordsListEl.addEventListener("input", onWordsListInput);
        wordsListEl.addEventListener("click", onWordsListClick);
      }

      if (statsToggleBtn) {
        statsToggleBtn.addEventListener("click", onStatsToggle);
      }
      if (statsDeleteKnownBtn) {
        statsDeleteKnownBtn.addEventListener("click", onStatsDeleteKnown);
      }
      if (statsExcludeKnownBtn) {
        statsExcludeKnownBtn.addEventListener("click", onStatsExcludeKnown);
      }

      if (deckCompleteStruggleBtn) {
        deckCompleteStruggleBtn.addEventListener(
          "click",
          onDeckCompletePracticeStruggle
        );
      }
      if (deckCompleteCloseBtn) {
        deckCompleteCloseBtn.addEventListener("click", onDeckCompleteClose);
      }

      // Default: decks panel open, focus mode always on
      setTopPanel("panel-decks");
      sessionInfoEl.textContent =
        "Focus learning is on: words you‚Äôre still learning will appear much more often.";
      goToNextCard();
    }

    init();
  </script>

  <!-- Keep your existing service worker file; this just registers it -->
  <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("./service-worker.js")
          .catch((err) => {
            console.log("Service worker registration failed:", err);
          });
      });
    }
  </script>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spanish Flashcards ‚Äì Level Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <meta name="theme-color" content="#0f172a" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Spanish Cards" />

  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
  />

  <style>
    :root {
      --bg-gradient: radial-gradient(circle at top left, #1e293b, #0f172a 60%, #020617);
      --card-bg: rgba(30, 41, 59, 0.7);
      --card-border: 1px solid rgba(148, 163, 184, 0.15);
      --accent: #22c55e;
      --accent-hover: #16a34a;
      --accent-soft: rgba(34, 197, 94, 0.15);
      --gold: #eab308;
      --gold-soft: rgba(234, 179, 8, 0.15);
      --text-main: #f1f5f9;
      --text-muted: #94a3b8;
      --danger: #ef4444;
      --danger-soft: rgba(239, 68, 68, 0.15);
      --radius-lg: 24px;
      --radius-md: 16px;
      --radius-sm: 12px;
      --shadow-soft: 0 10px 40px -10px rgba(0, 0, 0, 0.5);
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body {
      margin: 0;
      font-family: "Inter", system-ui, sans-serif;
      background: var(--bg-gradient);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 10px; 
    }

    /* --- App Container --- */
    .app {
      width: 100%;
      max-width: 800px;
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: var(--card-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-soft);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 85vh;
    }

    /* --- Header --- */
    .app-header {
      padding: 20px;
      border-bottom: var(--card-border);
      background: rgba(15, 23, 42, 0.8);
    }

    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 16px;
    }

    .logo-block h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
      letter-spacing: -0.02em;
    }

    .logo-pill {
      font-size: 10px;
      text-transform: uppercase;
      background: var(--accent-soft);
      border-radius: 99px;
      padding: 3px 8px;
      color: #86efac;
      letter-spacing: 0.05em;
      border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .deck-description {
      margin: 4px 0 0 0;
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.4;
    }

    /* Stats Pills */
    .stats-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .stat-pill {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 99px;
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-muted);
      display: inline-flex;
      gap: 4px;
      cursor: pointer;
      transition: 0.2s;
    }
    .stat-pill:hover { background: rgba(30, 41, 59, 0.9); border-color: var(--text-muted); }
    .stat-pill strong { color: var(--text-main); font-weight: 600; }
    .stat-pill.accent { border-color: rgba(34, 197, 94, 0.4); color: #bbf7d0; background: rgba(34, 197, 94, 0.1); }
    .stat-pill.danger { border-color: rgba(239, 68, 68, 0.4); color: #fecaca; background: rgba(239, 68, 68, 0.1); }

    /* --- Navigation Tabs --- */
    .nav-tabs {
      display: flex;
      gap: 8px;
      background: rgba(15, 23, 42, 0.6);
      padding: 4px;
      border-radius: 99px;
      border: var(--card-border);
      overflow-x: auto;
    }

    .nav-tab {
      flex: 1;
      border: none;
      background: transparent;
      color: var(--text-muted);
      padding: 8px 12px;
      border-radius: 99px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      white-space: nowrap;
    }
    .nav-tab:hover { color: var(--text-main); background: rgba(255,255,255,0.03); }
    .nav-tab.active {
      background: var(--accent);
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 2px 10px rgba(34, 197, 94, 0.3);
    }

    /* --- Panels --- */
    .panel-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow-y: auto;
      max-height: 75vh;
    }
    .panel { display: none; padding: 20px; animation: fadeIn 0.2s ease; }
    .panel.active { display: block; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

    /* Decks Grid */
    .deck-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; }
    .deck-card {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.1);
      border-radius: var(--radius-sm);
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      gap: 4px;
      position: relative;
    }
    .deck-card:hover { background: rgba(30, 41, 59, 0.9); border-color: rgba(148, 163, 184, 0.3); transform: translateY(-2px); }
    .deck-card.active { border-color: var(--accent); background: rgba(34, 197, 94, 0.05); }
    
    .deck-card.level-complete {
      border-color: var(--gold);
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.6), rgba(234, 179, 8, 0.05));
    }
    .deck-card.level-complete::after {
      content: '‚òÖ'; position: absolute; top: 8px; right: 10px; color: var(--gold); font-size: 14px;
    }

    .deck-title { font-weight: 600; font-size: 14px; }
    .deck-count { font-size: 12px; color: var(--text-muted); }

    /* Breadcrumbs */
    .breadcrumbs { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; }
    .back-btn {
      background: transparent; border: 1px solid rgba(148, 163, 184, 0.3);
      color: var(--text-muted); padding: 4px 10px; border-radius: 99px;
      font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 4px;
    }
    .back-btn:hover { border-color: var(--text-muted); color: var(--text-main); }

    /* Settings */
    .setting-group { margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid rgba(148,163,184,0.1); }
    .setting-group:last-child { border-bottom: none; }
    .setting-header { font-size: 13px; color: var(--text-main); margin-bottom: 8px; font-weight: 500; }
    .toggle-row { display: flex; gap: 4px; background: rgba(15,23,42,0.4); padding: 3px; border-radius: 99px; width: fit-content; border: 1px solid rgba(148,163,184,0.1); flex-wrap: wrap; }
    .toggle-btn {
      border: none; background: transparent; color: var(--text-muted);
      padding: 6px 12px; border-radius: 99px; font-size: 12px; cursor: pointer; transition: 0.2s;
    }
    .toggle-btn.active { background: var(--accent); color: #022c22; font-weight: 600; }
    
    .setting-check-btn {
      display: flex; align-items: center; justify-content: space-between;
      width: 100%; padding: 10px; border-radius: var(--radius-sm);
      background: rgba(30, 41, 59, 0.4); border: 1px solid rgba(148,163,184,0.1);
      cursor: pointer; margin-bottom: 8px; font-size: 13px; color: var(--text-muted);
    }
    .setting-check-btn.checked { background: rgba(34, 197, 94, 0.1); border-color: rgba(34, 197, 94, 0.3); color: #bbf7d0; }

    /* Add Card Form */
    .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .form-group { display: flex; flex-direction: column; gap: 6px; }
    .form-group.full { grid-column: span 2; }
    label { font-size: 12px; color: var(--text-muted); font-weight: 500; }
    input, textarea, select {
      background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text-main); padding: 12px; border-radius: var(--radius-sm);
      font-family: inherit; font-size: 15px; outline: none; transition: 0.2s;
      width: 100%;
    }
    input:focus, textarea:focus, select:focus { border-color: var(--accent); background: rgba(15, 23, 42, 0.8); }
    .btn-submit {
      width: 100%; background: var(--accent); color: #022c22; border: none;
      padding: 14px; border-radius: var(--radius-sm); font-weight: 600; font-size: 15px;
      cursor: pointer; margin-top: 12px;
    }
    .btn-submit:hover { background: var(--accent-hover); }
    .toggle-ex-btn {
      background: transparent; border: 1px dashed rgba(148,163,184,0.3); color: var(--text-muted);
      width: 100%; padding: 8px; border-radius: var(--radius-sm); cursor: pointer; font-size: 12px;
    }
    .toggle-ex-btn:hover { border-color: var(--accent); color: var(--accent); }

    /* Words Manager */
    .filter-bar { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
    .filter-input { flex: 1; min-width: 120px; padding: 8px; font-size: 13px; }
    .word-list { display: flex; flex-direction: column; gap: 6px; }
    .word-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px; background: rgba(30,41,59,0.5); border-radius: var(--radius-sm);
      border: 1px solid rgba(148,163,184,0.1);
    }
    .word-info { flex: 1; }
    .word-main { font-weight: 600; font-size: 14px; color: var(--text-main); }
    .word-sub { font-size: 11px; color: var(--text-muted); }
    .word-tag { font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: 6px; background: rgba(0,0,0,0.3); color: #94a3b8; }
    .word-score { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 8px; }
    .score-0 { background: #334155; }
    .score-1 { background: #fca5a5; }
    .score-3 { background: #bae6fd; }
    .score-4 { background: #4ade80; }
    
    .btn-icon { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 6px; font-size: 14px; }
    .btn-icon:hover { color: var(--danger); }

    /* Game Card */
    .game-area {
      flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; min-height: 400px;
    }
    .flashcard {
      width: 100%; max-width: 500px; min-height: 280px;
      background: var(--bg-gradient);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: var(--radius-lg);
      padding: 30px;
      display: flex; flex-direction: column; justify-content: space-between;
      position: relative; box-shadow: 0 20px 50px -12px rgba(0,0,0,0.5);
    }
    .card-meta { display: flex; justify-content: space-between; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 20px; }
    .card-main { text-align: center; flex: 1; display: flex; flex-direction: column; justify-content: center; }
    .label-lang { font-size: 11px; color: var(--text-muted); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
    .word-text { font-size: 36px; font-weight: 700; color: var(--text-main); margin-bottom: 20px; line-height: 1.2; word-break: break-word; }
    .reveal-section { border-top: 1px dashed rgba(148,163,184,0.2); padding-top: 20px; margin-top: 10px; animation: fadeIn 0.3s ease; }
    .reveal-text { font-size: 24px; font-weight: 500; color: #bae6fd; margin-bottom: 8px; }
    .examples { font-size: 14px; color: var(--text-muted); font-style: italic; line-height: 1.5; }

    /* Game Actions */
    .action-row { display: flex; gap: 8px; width: 100%; max-width: 500px; }
    .btn-action {
      flex: 1; border: 1px solid rgba(148,163,184,0.2); background: rgba(30,41,59,0.5);
      color: var(--text-main); padding: 12px; border-radius: 99px; font-size: 14px;
      cursor: pointer; transition: 0.2s; font-weight: 500;
    }
    .btn-action:hover { background: rgba(30,41,59,0.8); transform: translateY(-1px); }
    .btn-action.primary { background: var(--text-main); color: #020617; font-weight: 600; border: none; }
    .btn-action.primary:hover { background: #e2e8f0; }
    .btn-action.success { background: var(--accent); color: #064e3b; border: none; font-weight: 600; }
    .btn-action.danger { background: rgba(239,68,68,0.2); color: #fca5a5; border-color: rgba(239,68,68,0.5); }
    .btn-action.ghost { background: transparent; border-color: transparent; color: var(--text-muted); font-size: 12px; flex: 0; white-space: nowrap; }
    .btn-action.ghost:hover { color: var(--danger); }

    .input-answer {
      width: 100%; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 14px; border-radius: 99px; color: white; font-size: 16px; text-align: center;
      margin-bottom: 10px; outline: none;
    }
    .input-answer:focus { border-color: var(--accent); }

    /* Overlay */
    .overlay { position: fixed; inset: 0; background: rgba(2, 6, 23, 0.9); z-index: 100; display: none; align-items: center; justify-content: center; backdrop-filter: blur(4px); }
    .overlay-content { background: #1e293b; padding: 30px; border-radius: var(--radius-lg); text-align: center; max-width: 90%; width: 400px; border: 1px solid rgba(148,163,184,0.2); }
    .confetti-container { position: fixed; inset: 0; pointer-events: none; z-index: 101; overflow: hidden; }
    .confetti { position: absolute; width: 8px; height: 14px; animation: fall 3s linear forwards; }
    @keyframes fall { to { transform: translateY(110vh) rotate(360deg); opacity: 0; } }

    @media (max-width: 600px) {
      .app { min-height: 100vh; border-radius: 0; border: none; }
      .flashcard { min-height: 240px; padding: 20px; }
      .word-text { font-size: 28px; }
      .form-grid { grid-template-columns: 1fr; }
      .form-group.full { grid-column: span 1; }
      .nav-tabs { justify-content: flex-start; }
    }
  </style>
</head>
<body>

<div class="app">
  <header class="app-header">
    <div class="header-top">
      <div class="logo-block">
        <h1>Spanish Flashcards <span class="logo-pill">PRO</span></h1>
        <p class="deck-description" id="headerDesc">Select a difficulty to begin.</p>
      </div>
      <div class="stats-row">
        <div class="stat-pill accent" onclick="openWordsTab('known')">Known: <strong id="statKnown">0</strong></div>
        <div class="stat-pill danger" onclick="openWordsTab('learning')">Learning: <strong id="statLearning">0</strong></div>
        <div class="stat-pill" onclick="openWordsTab('all')">Total: <strong id="statTotal">0</strong></div>
      </div>
    </div>

    <div class="nav-tabs">
      <button class="nav-tab active" data-panel="decks">üìö Decks</button>
      <button class="nav-tab" data-panel="game">üéÆ Play</button>
      <button class="nav-tab" data-panel="words">üóÇ Words</button>
      <button class="nav-tab" data-panel="add">‚ûï Add</button>
      <button class="nav-tab" data-panel="settings">‚öôÔ∏è Settings</button>
    </div>
  </header>

  <div class="panel-container">
    
    <div id="panel-decks" class="panel active">
      <div id="deckBreadcrumbs" class="breadcrumbs"></div>
      <div id="deckGrid" class="deck-grid">
        <div style="padding:20px; color:var(--text-muted)">Loading...</div>
      </div>
    </div>

    <div id="panel-game" class="panel">
      <div class="game-area">
        <div class="flashcard" id="gameCard">
          <div class="card-meta">
            <span id="gameDeckName">All Decks</span>
            <span id="gameStrength">New Word</span>
          </div>
          
          <div class="card-main">
            <div class="label-lang" id="gameFrontLabel">Spanish</div>
            <div class="word-text" id="gameFrontText">Pick a deck to start</div>
            
            <div id="gameInputArea" style="display:none; width:100%;">
              <input type="text" class="input-answer" id="gameInput" placeholder="Type answer..." autocomplete="off" autocapitalize="off">
              <div id="gameFeedback" style="font-size:13px; min-height:20px;"></div>
            </div>

            <div class="reveal-section" id="gameReveal" style="display:none">
              <div class="label-lang" id="gameBackLabel">English</div>
              <div class="reveal-text" id="gameBackText">...</div>
              <div class="examples" id="gameExamples"></div>
            </div>
          </div>
        </div>

        <div class="action-row" id="gameControlsStart">
          <button class="btn-action ghost" id="btnDeleteCard" title="Permanently Delete">üóë Remove</button>
          <button class="btn-action primary" id="btnShowAnswer">Show Answer</button>
        </div>

        <div class="action-row" id="gameControlsJudge" style="display:none">
          <button class="btn-action danger" id="btnHard">Still Learning</button>
          <button class="btn-action success" id="btnEasy">I Knew It</button>
        </div>
        
        <div class="action-row" id="gameControlsNext" style="display:none">
           <button class="btn-action primary" id="btnNextCard">Next Card ‚û°</button>
        </div>
      </div>
    </div>

    <div id="panel-add" class="panel">
      <div class="form-grid">
        <div class="form-group">
          <label>Spanish Word</label>
          <input type="text" id="addEs" placeholder="e.g. la mesa" autocapitalize="off" autocomplete="off">
        </div>
        <div class="form-group">
          <label>English Translation</label>
          <input type="text" id="addEn" placeholder="e.g. the table" autocapitalize="off" autocomplete="off">
        </div>
        <div class="form-group full">
          <label>Category (Topic)</label>
          <select id="addTopicSelect"></select>
          <div style="font-size:11px; color:var(--text-muted); margin-top:4px;">
            Added words appear in <strong>Mix</strong> decks and specific <strong>Topic</strong> decks across all levels.
          </div>
        </div>
        
        <div class="form-group full">
          <button type="button" class="toggle-ex-btn" id="btnToggleEx" onclick="toggleAddEx()">‚ûï Add Examples (Optional)</button>
        </div>

        <div class="form-group full" id="divAddEx" style="display:none">
          <textarea id="addExEs" placeholder="Spanish example sentence..." rows="2" autocapitalize="off"></textarea>
          <textarea id="addExEn" placeholder="English translation..." rows="2" autocapitalize="off" style="margin-top:8px"></textarea>
        </div>

        <div class="form-group full">
          <button class="btn-submit" id="btnAddSubmit">Save Card</button>
          <div id="addMsg" style="text-align:center; font-size:12px; margin-top:8px; min-height:16px;"></div>
        </div>
      </div>
    </div>

    <div id="panel-words" class="panel">
       <div class="filter-bar">
         <select id="filterStatus" class="input-answer filter-input" onchange="renderWordList()">
           <option value="all">All Status</option>
           <option value="known">Known / Mastered</option>
           <option value="learning">Still Learning</option>
         </select>
         <select id="filterTopic" class="input-answer filter-input" onchange="renderWordList()">
           <option value="all">All Categories</option>
         </select>
         <select id="filterSort" class="input-answer filter-input" onchange="renderWordList()">
            <option value="diff">Sort: Difficulty</option>
            <option value="az">Sort: A-Z (ES)</option>
         </select>
       </div>
       <div id="wordListContainer" class="word-list">
          </div>
    </div>

    <div id="panel-settings" class="panel">
      <div class="setting-group">
        <div class="setting-header">Custom Content</div>
        <div class="setting-check-btn" id="btnToggleIncludeCustom" onclick="toggleSetting('includeCustom')">
           <span>Include my added words in decks</span>
           <span class="status-icon">‚úì</span>
        </div>
        <div class="setting-check-btn" id="btnToggleOnlyCustom" onclick="toggleSetting('onlyCustom')">
           <span>Play ONLY my added words</span>
           <span class="status-icon">‚óã</span>
        </div>
      </div>

      <div class="setting-group">
        <div class="setting-header">Practice Direction</div>
        <div class="toggle-row">
          <button class="toggle-btn active" data-group="dir" data-val="es-en">Spanish ‚Üí English</button>
          <button class="toggle-btn" data-group="dir" data-val="en-es">English ‚Üí Spanish</button>
        </div>
      </div>

      <div class="setting-group">
        <div class="setting-header">Answer Mode</div>
        <div class="toggle-row">
          <button class="toggle-btn active" data-group="mode" data-val="reveal">Self Check</button>
          <button class="toggle-btn" data-group="mode" data-val="type">Type Answer</button>
        </div>
      </div>

      <div class="setting-group">
        <div class="setting-header">Game Rules</div>
        <div class="setting-check-btn" id="btnToggleKnownOnce" onclick="toggleSetting('knownOnce')">
           <span>Review known words only once per session</span>
           <span class="status-icon">‚óã</span>
        </div>
        <div style="font-size:11px; color:var(--text-muted); margin-top:4px; line-height:1.4">
          If enabled, mastered words will appear once (for review) and then be removed from the rotation so you can focus on new words.
        </div>
      </div>

      <div class="setting-group">
        <div class="setting-header">Data</div>
        <button class="btn-action danger" id="btnResetData" style="width:100%">Reset All Progress</button>
      </div>
    </div>

  </div>

  <div class="overlay" id="overlay">
    <div class="overlay-content">
      <h2 style="margin-top:0">üéâ Deck Complete!</h2>
      
      <div style="display:flex; justify-content:center; gap:10px; margin-bottom:20px;">
        <div class="stat-pill accent">1st Time Correct: <strong id="resCorrect">0</strong></div>
        <div class="stat-pill danger">Struggled: <strong id="resStruggle">0</strong></div>
      </div>
      
      <button class="btn-action primary" onclick="closeOverlay()">Back to Decks</button>
      <button class="btn-action danger" id="btnPracticeStruggle" style="margin-top:10px" onclick="startPracticeStruggle()">Practice Struggle Words</button>
    </div>
  </div>

</div>

<script>
/**
 * APP LOGIC
 */
const STATE = {
  decksRaw: [], // Loaded from JSON
  activeDecks: [], // Flattened list
  customCards: {}, // { topicId: [cards] } 
  progress: {}, // { cardId: { score, seen, ... } }
  blacklist: new Set(), // Deleted card IDs
  
  // Session State
  sessionSeen: new Set(), // Track what we've seen this session
  lastCardUid: null, // Track previous card to avoid dupes
  revealTime: 0, // Timestamp when answer revealed
  sessionStats: { correctFirst: 0, struggle: 0 },
  struggleList: [], // UIDs of struggled words in this session
  
  // Navigation
  view: 'root', 
  selDiff: null,
  selLevel: null,
  
  // Game Config
  currentDeckId: null,
  currentCard: null,
  isStruggleMode: false,
  
  // Settings
  direction: 'es-en',
  mode: 'reveal',
  includeCustom: true,
  onlyCustom: false,
  knownOnce: false
};

// --- INIT ---
async function init() {
  loadLocalData();
  await loadRemoteData();
  bindEvents();
  renderDecks();
  updateStats();
  populateAddDropdown();
}

// --- DATA HANDLING ---
async function loadRemoteData() {
  try {
    const res = await fetch('decks.json');
    if(!res.ok) throw new Error("404");
    const json = await res.json();
    STATE.decksRaw = json;
    
    // Flatten decks for easy access
    STATE.activeDecks = json.decks.map(d => ({ ...d, cards: [...d.cards] }));
    
    // Inject custom cards
    injectCustomCards();
    
    // Initial Render
    renderDecks();
  } catch (e) {
    document.getElementById('deckGrid').innerHTML = `<div style="padding:20px; color:#fca5a5">Error loading decks.json. Ensure file exists and is accessible.</div>`;
  }
}

function loadLocalData() {
  const custom = localStorage.getItem('sf_custom');
  if(custom) STATE.customCards = JSON.parse(custom);

  const prog = localStorage.getItem('sf_progress');
  if(prog) STATE.progress = JSON.parse(prog);

  const black = localStorage.getItem('sf_blacklist');
  if(black) STATE.blacklist = new Set(JSON.parse(black));
  
  // Load settings
  const settings = JSON.parse(localStorage.getItem('sf_settings') || '{}');
  if(settings.dir) changeToggle('dir', settings.dir);
  if(settings.mode) changeToggle('mode', settings.mode);
  
  STATE.includeCustom = settings.includeCustom !== false;
  STATE.onlyCustom = settings.onlyCustom === true;
  STATE.knownOnce = settings.knownOnce === true;
  if(settings.selDiff) STATE.selDiff = settings.selDiff;

  updateCheckUI('includeCustom', STATE.includeCustom);
  updateCheckUI('onlyCustom', STATE.onlyCustom);
  updateCheckUI('knownOnce', STATE.knownOnce);
}

function saveData() {
  localStorage.setItem('sf_custom', JSON.stringify(STATE.customCards));
  localStorage.setItem('sf_progress', JSON.stringify(STATE.progress));
  localStorage.setItem('sf_blacklist', JSON.stringify([...STATE.blacklist]));
  
  const settings = {
    dir: STATE.direction,
    mode: STATE.mode,
    includeCustom: STATE.includeCustom,
    onlyCustom: STATE.onlyCustom,
    knownOnce: STATE.knownOnce,
    selDiff: STATE.selDiff
  };
  localStorage.setItem('sf_settings', JSON.stringify(settings));
}

function injectCustomCards() {
  STATE.activeDecks.forEach(deck => {
    const topicCards = STATE.customCards[deck.topicId] || [];
    topicCards.forEach(c => {
       const exists = deck.cards.find(ex => ex.es === c.es && ex._custom);
       if(!exists) deck.cards.push(c);
    });
  });
}

// --- DECK NAVIGATION UI ---
const domGrid = document.getElementById('deckGrid');
const domBread = document.getElementById('deckBreadcrumbs');
const domHeaderDesc = document.getElementById('headerDesc');

function renderDecks() {
  domGrid.innerHTML = '';
  domBread.innerHTML = '';
  
  // 1. Root: Select Difficulty
  if(!STATE.selDiff) {
    domHeaderDesc.textContent = "Select your difficulty level.";
    if(!STATE.decksRaw.difficulties) return;
    STATE.decksRaw.difficulties.forEach(diff => {
      const el = createCard(diff.label, "Difficulty", () => {
        STATE.selDiff = diff.id;
        STATE.view = 'level';
        saveData();
        renderDecks();
      });
      domGrid.appendChild(el);
    });
    return;
  }

  // 2. Levels
  const diffObj = STATE.decksRaw.difficulties.find(d => d.id === STATE.selDiff);
  if(STATE.selDiff && !STATE.selLevel) {
    domHeaderDesc.textContent = `Select a level in ${diffObj.label}.`;
    addBreadcrumb("Difficulties", () => { STATE.selDiff = null; renderDecks(); });
    
    // Find levels
    const levels = new Set(STATE.activeDecks.filter(d => d.difficultyId === STATE.selDiff).map(d => d.levelIndex));
    [...levels].sort().forEach(lvl => {
      // Check Completion
      const isComplete = checkLevelComplete(STATE.selDiff, lvl);
      
      const el = createCard(`Level ${lvl}`, `${diffObj.label}`, () => {
        STATE.selLevel = lvl;
        renderDecks();
      });
      
      if(isComplete) el.classList.add('level-complete');
      domGrid.appendChild(el);
    });
    return;
  }

  // 3. Decks
  if(STATE.selDiff && STATE.selLevel) {
    domHeaderDesc.textContent = `Pick a topic to study.`;
    addBreadcrumb("Difficulties", () => { STATE.selDiff = null; STATE.selLevel = null; renderDecks(); });
    addBreadcrumb(`Level ${STATE.selLevel}`, () => { STATE.selLevel = null; renderDecks(); });
    
    // Filter decks
    const decks = STATE.activeDecks.filter(d => d.difficultyId === STATE.selDiff && d.levelIndex === STATE.selLevel);
    
    // Calculate Mix Deck Count
    let mixCount = 0;
    decks.forEach(d => { mixCount += getPlayableCount(d); });
    
    // Add Mix Deck Option
    const mixEl = createCard("‚ö° Mix All Topics", `${mixCount} cards`, () => {
       startSession(null, true); 
    });
    mixEl.classList.add('active');
    domGrid.appendChild(mixEl);

    decks.forEach(d => {
      // Get Topic Name
      const topic = STATE.decksRaw.topics.find(t => t.id === d.topicId);
      const label = topic ? topic.label : d.name;
      const count = getPlayableCount(d);
      
      const el = createCard(label, `${count} cards`, () => {
        startSession(d.id);
      });
      domGrid.appendChild(el);
    });
  }
}

function checkLevelComplete(diffId, levelIdx) {
  // Level is complete if all non-custom words have score >= 4
  const decks = STATE.activeDecks.filter(d => d.difficultyId === diffId && d.levelIndex === levelIdx);
  if(decks.length === 0) return false;
  
  let totalBase = 0;
  let masteredBase = 0;
  
  decks.forEach(d => {
    d.cards.forEach(c => {
      if(c._custom) return; // Exclude custom words
      totalBase++;
      const uid = getCardId(d.id, c);
      const score = (STATE.progress[uid] || {}).score || 0;
      if(score >= 4) masteredBase++;
    });
  });
  
  return totalBase > 0 && totalBase === masteredBase;
}

function createCard(title, sub, onClick) {
  const div = document.createElement('div');
  div.className = 'deck-card';
  div.innerHTML = `<div class="deck-title">${title}</div><div class="deck-count">${sub}</div>`;
  div.onclick = onClick;
  return div;
}

function addBreadcrumb(label, onClick) {
  const btn = document.createElement('button');
  btn.className = 'back-btn';
  btn.innerHTML = `‚Äπ ${label}`;
  btn.onclick = onClick;
  domBread.appendChild(btn);
}

function getPlayableCount(deck) {
  return deck.cards.filter(c => {
    const id = getCardId(deck.id, c);
    if(STATE.blacklist.has(id)) return false;
    if(STATE.onlyCustom && !c._custom) return false;
    if(!STATE.includeCustom && c._custom) return false;
    return true;
  }).length;
}

// --- GAME LOGIC ---
function startSession(deckId, isMix = false) {
  STATE.currentDeckId = deckId;
  STATE.sessionSeen = new Set();
  STATE.lastCardUid = null;
  STATE.isStruggleMode = false;
  STATE.sessionStats = { correctFirst: 0, struggle: 0 };
  STATE.struggleList = [];
  
  if(!isMix && !deckId) return;
  
  const pool = getPoolFromCurrentSession();
  
  if(pool.length === 0) {
    alert("No cards available with current filters!");
    return;
  }
  
  switchPanel('game');
  nextCard();
}

function startPracticeStruggle() {
  if(STATE.struggleList.length === 0) return;
  
  STATE.isStruggleMode = true;
  STATE.sessionSeen = new Set();
  STATE.lastCardUid = null;
  
  document.getElementById('overlay').style.display = 'none';
  nextCard();
}

function nextCard() {
  let pool = [];
  
  if(STATE.isStruggleMode) {
    // Reconstruct pool from struggle UIDs
    // We need to find the card objects again. Inefficient but safe.
    STATE.activeDecks.forEach(d => {
      d.cards.forEach(c => {
         const uid = getCardId(d.id, c);
         if(STATE.struggleList.includes(uid)) {
           pool.push({ ...c, _realDeckId: d.id, _uid: uid });
         }
      });
    });
  } else {
    pool = getPoolFromCurrentSession();
  }
  
  // Filter Pool based on Game Rules
  const playable = pool.filter(c => {
    // 1. "Review Known Once" Logic
    if(STATE.knownOnce && !STATE.isStruggleMode) {
      const score = (STATE.progress[c._uid] || {}).score || 0;
      if(score >= 4 && STATE.sessionSeen.has(c._uid)) return false;
    }
    // 2. No Repeats
    if(pool.length > 1 && c._uid === STATE.lastCardUid) return false;
    return true;
  });

  if(playable.length === 0) {
    showDeckComplete();
    return;
  }
  
  // Simple Random
  const card = playable[Math.floor(Math.random() * playable.length)];
  
  STATE.currentCard = card;
  STATE.lastCardUid = card._uid;
  STATE.sessionSeen.add(card._uid);
  renderGameCard();
}

function getPoolFromCurrentSession() {
  let pool = [];
  const isMix = !STATE.currentDeckId;
  const relevantDecks = isMix 
    ? STATE.activeDecks.filter(d => d.difficultyId === STATE.selDiff && d.levelIndex === STATE.selLevel)
    : [STATE.activeDecks.find(d => d.id === STATE.currentDeckId)];
    
  relevantDecks.forEach(d => {
    d.cards.forEach((c, idx) => {
      const uid = getCardId(d.id, c);
      if(STATE.blacklist.has(uid)) return;
      if(STATE.onlyCustom && !c._custom) return;
      if(!STATE.includeCustom && c._custom) return;
      pool.push({ ...c, _realDeckId: d.id, _realIndex: idx, _uid: uid });
    });
  });
  return pool;
}

function renderGameCard() {
  const c = STATE.currentCard;
  const isEs = STATE.direction === 'es-en';
  
  // Reset UI
  document.getElementById('gameReveal').style.display = 'none';
  document.getElementById('gameControlsJudge').style.display = 'none';
  document.getElementById('gameControlsNext').style.display = 'none';
  document.getElementById('gameControlsStart').style.display = 'flex';
  document.getElementById('btnShowAnswer').style.display = 'block';
  document.getElementById('gameInputArea').style.display = STATE.mode === 'type' ? 'block' : 'none';
  document.getElementById('gameInput').value = '';
  document.getElementById('gameFeedback').textContent = '';
  
  // Content
  const deckName = STATE.activeDecks.find(d => d.id === c._realDeckId)?.name || "";
  document.getElementById('gameDeckName').textContent = deckName;
  
  // Progress
  const score = (STATE.progress[c._uid] || {}).score || 0;
  let strLabel = "New Word";
  if(score > 0) strLabel = "Learning";
  if(score >= 4) strLabel = "Mastered";
  document.getElementById('gameStrength').textContent = strLabel;
  
  document.getElementById('gameFrontLabel').textContent = isEs ? "Spanish" : "English";
  document.getElementById('gameFrontText').textContent = isEs ? c.es : c.en;
  
  document.getElementById('gameBackLabel').textContent = isEs ? "English" : "Spanish";
  document.getElementById('gameBackText').textContent = isEs ? c.en : c.es;
  
  let ex = "";
  if(c.exampleEs && c.exampleEn) {
    ex = `"${c.exampleEs}"<br>"${c.exampleEn}"`;
  }
  document.getElementById('gameExamples').innerHTML = ex;
}

function showAnswer(force = false) {
  STATE.revealTime = Date.now(); // Track time
  
  if(STATE.mode === 'type' && !force) {
    const input = document.getElementById('gameInput');
    const val = input.value.trim().toLowerCase();
    const isEs = STATE.direction === 'es-en';
    const target = (isEs ? STATE.currentCard.en : STATE.currentCard.es).toLowerCase();
    
    const clean = str => str.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    
    if(clean(val) === clean(target)) {
      document.getElementById('gameFeedback').textContent = "‚úÖ Correct!";
      document.getElementById('gameFeedback').style.color = "#4ade80";
      markCard(true); 
      return; 
    } else {
      document.getElementById('gameFeedback').textContent = `‚ùå Incorrect.`;
      document.getElementById('gameFeedback').style.color = "#f87171";
    }
  }

  document.getElementById('gameReveal').style.display = 'block';
  document.getElementById('gameControlsStart').style.display = 'none';
  
  if(STATE.mode === 'reveal') {
    document.getElementById('gameControlsJudge').style.display = 'flex';
  } else {
    document.getElementById('gameControlsNext').style.display = 'flex';
  }
}

function markCard(success) {
  const c = STATE.currentCard;
  if(!STATE.progress[c._uid]) STATE.progress[c._uid] = { score: 0, seen: 0 };
  
  STATE.progress[c._uid].seen++;
  const diff = Date.now() - STATE.revealTime; // Time taken to decide

  if(success) {
     if(STATE.progress[c._uid].seen === 1) STATE.sessionStats.correctFirst++;
     
     // TIME LOGIC:
     // If correct < 3 seconds -> Mastered (4)
     // If correct > 3 seconds -> Review Once (3) 
     if(diff <= 3000) {
       STATE.progress[c._uid].score = 4;
     } else {
       // If currently mastered, keep it. If not, set to 3.
       if(STATE.progress[c._uid].score < 4) STATE.progress[c._uid].score = 3; 
       // Also add to struggle list if it wasn't mastered before
       if(!STATE.struggleList.includes(c._uid)) STATE.struggleList.push(c._uid);
     }
  } else {
     // Still Learning
     STATE.progress[c._uid].score = Math.max(0, STATE.progress[c._uid].score - 1);
     STATE.sessionStats.struggle++;
     if(!STATE.struggleList.includes(c._uid)) STATE.struggleList.push(c._uid);
  }
  
  saveData();
  updateStats();
  nextCard();
}

function showDeckComplete() {
  document.getElementById('overlay').style.display = 'flex';
  document.getElementById('resCorrect').textContent = STATE.sessionStats.correctFirst;
  document.getElementById('resStruggle').textContent = STATE.sessionStats.struggle; // Using session counter
  
  const btnStruggle = document.getElementById('btnPracticeStruggle');
  if(STATE.struggleList.length > 0) {
    btnStruggle.style.display = 'inline-block';
    btnStruggle.textContent = `Practice Struggle Words (${STATE.struggleList.length})`;
  } else {
    btnStruggle.style.display = 'none';
  }
  
  launchConfetti();
}

function closeOverlay() {
  document.getElementById('overlay').style.display = 'none';
  switchPanel('decks');
}

function launchConfetti() {
  const colors = ['#22c55e', '#38bdf8', '#facc15', '#f43f5e'];
  for(let i=0; i<50; i++) {
    const el = document.createElement('div');
    el.className = 'confetti';
    el.style.left = Math.random()*100 + 'vw';
    el.style.backgroundColor = colors[Math.floor(Math.random()*colors.length)];
    el.style.animationDuration = (Math.random()*2 + 2) + 's';
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 4000);
  }
}

function deleteCurrentCard() {
  if(!confirm("Permanently remove this card?")) return;
  const c = STATE.currentCard;
  
  if(c._custom) {
    const topicCards = STATE.customCards[STATE.activeDecks.find(d => d.id === c._realDeckId).topicId];
    if(topicCards) {
      const idx = topicCards.findIndex(x => x.es === c.es && x.en === c.en);
      if(idx > -1) topicCards.splice(idx, 1);
    }
  } 
  
  STATE.blacklist.add(c._uid);
  saveData();
  updateStats();
  nextCard();
}

// --- WORDS MANAGER UI ---
function openWordsTab(filter) {
  switchPanel('words');
  document.getElementById('filterStatus').value = filter || 'all';
  renderWordList();
}

function renderWordList() {
  const container = document.getElementById('wordListContainer');
  const fStatus = document.getElementById('filterStatus').value;
  const fTopic = document.getElementById('filterTopic').value;
  const fSort = document.getElementById('filterSort').value;
  
  container.innerHTML = 'Loading...';

  // Gather ALL cards
  const allCardsMap = new Map();
  STATE.activeDecks.forEach(d => {
    d.cards.forEach(c => {
       const uid = getCardId(d.id, c);
       if(STATE.blacklist.has(uid)) return;
       
       const score = (STATE.progress[uid] || {}).score || 0;
       if(fStatus === 'known' && score < 4) return;
       if(fStatus === 'learning' && score >= 4) return;

       if(fTopic !== 'all' && d.topicId !== fTopic) return;
       
       allCardsMap.set(uid, { ...c, _deckName: d.name, _score: score, _uid: uid });
    });
  });
  
  let list = Array.from(allCardsMap.values());
  
  // Sort
  if(fSort === 'az') {
    list.sort((a,b) => a.es.localeCompare(b.es));
  } else if (fSort === 'diff') {
     list.sort((a,b) => a._score - b._score);
  }
  
  container.innerHTML = '';
  if(list.length === 0) {
    container.innerHTML = '<div style="padding:20px; text-align:center; color:var(--text-muted)">No words match filter.</div>';
    return;
  }
  
  const renderLimit = list.slice(0, 100); 
  
  renderLimit.forEach(c => {
    const scoreClass = c._score >= 4 ? 'score-4' : (c._score === 3 ? 'score-3' : (c._score > 0 ? 'score-1' : 'score-0'));
    const el = document.createElement('div');
    el.className = 'word-row';
    el.innerHTML = `
      <div class="word-info">
        <div class="word-main">
          <span class="word-score ${scoreClass}"></span>
          ${c.es} 
          <span style="font-weight:400; color:var(--text-muted)">‚Äî ${c.en}</span>
        </div>
        <div class="word-sub">
          ${c._deckName}
          ${c._custom ? '<span class="word-tag">Custom</span>' : ''}
        </div>
      </div>
      <button class="btn-icon" onclick="deleteWordByUid('${c._uid}')">üóë</button>
    `;
    container.appendChild(el);
  });
  
  if(list.length > 100) {
     const more = document.createElement('div');
     more.style.textAlign = 'center';
     more.style.fontSize = '12px';
     more.style.padding = '10px';
     more.style.color = 'var(--text-muted)';
     more.textContent = `...and ${list.length - 100} more`;
     container.appendChild(more);
  }
}

function deleteWordByUid(uid) {
  if(!confirm("Permanently delete word?")) return;
  STATE.blacklist.add(uid);
  saveData();
  renderWordList(); // Re-render
  updateStats();
}

function populateTopicFilter() {
  const sel = document.getElementById('filterTopic');
  sel.innerHTML = '<option value="all">All Categories</option>';
  if(STATE.decksRaw.topics) {
    STATE.decksRaw.topics.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.label;
      sel.appendChild(opt);
    });
  }
}

// --- ADD CARD UI ---
function populateAddDropdown() {
  const sel = document.getElementById('addTopicSelect');
  sel.innerHTML = '';
  if(STATE.decksRaw.topics) {
    STATE.decksRaw.topics.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.label;
      sel.appendChild(opt);
    });
  }
}

function toggleAddEx() {
  const div = document.getElementById('divAddEx');
  const btn = document.getElementById('btnToggleEx');
  if(div.style.display === 'none') {
    div.style.display = 'block';
    btn.textContent = '‚ûñ Hide Examples';
  } else {
    div.style.display = 'none';
    btn.textContent = '‚ûï Add Examples (Optional)';
  }
}

function onAddSubmit() {
  const es = document.getElementById('addEs').value.trim();
  const en = document.getElementById('addEn').value.trim();
  const topicId = document.getElementById('addTopicSelect').value;
  const exEs = document.getElementById('addExEs').value.trim();
  const exEn = document.getElementById('addExEn').value.trim();
  
  if(!es || !en || !topicId) {
    document.getElementById('addMsg').textContent = "Please fill required fields.";
    document.getElementById('addMsg').style.color = "#f87171";
    return;
  }
  
  const newCard = { es, en, exampleEs: exEs, exampleEn: exEn, _custom: true };
  
  if(!STATE.customCards[topicId]) STATE.customCards[topicId] = [];
  STATE.customCards[topicId].push(newCard);
  
  STATE.activeDecks.forEach(d => {
    if(d.topicId === topicId) {
       d.cards.push(newCard);
    }
  });
  
  saveData();
  updateStats();
  
  const topicLabel = STATE.decksRaw.topics.find(t=>t.id===topicId)?.label || "Topic";
  document.getElementById('addMsg').textContent = `Added to ${topicLabel} decks!`;
  document.getElementById('addMsg').style.color = "#4ade80";
  
  document.getElementById('addEs').value = '';
  document.getElementById('addEn').value = '';
  document.getElementById('addExEs').value = '';
  document.getElementById('addExEn').value = '';
  document.getElementById('addEs').focus();
  
  setTimeout(() => document.getElementById('addMsg').textContent = '', 2000);
}


// --- UTILS ---
function switchPanel(panelId) {
  document.querySelectorAll('.panel').forEach(el => el.classList.remove('active'));
  document.getElementById('panel-'+panelId).classList.add('active');
  
  document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
  const navBtn = document.querySelector(`.nav-tab[data-panel="${panelId}"]`);
  if(navBtn) navBtn.classList.add('active');
  
  if(panelId === 'decks') renderDecks();
  if(panelId === 'words') { populateTopicFilter(); renderWordList(); }
}

function changeToggle(group, val) {
  document.querySelectorAll(`.toggle-btn[data-group="${group}"]`).forEach(btn => {
    if(btn.dataset.val === val) btn.classList.add('active');
    else btn.classList.remove('active');
  });
  
  if(group === 'dir') STATE.direction = val;
  if(group === 'mode') STATE.mode = val;
  saveData();
}

function toggleSetting(key) {
  STATE[key] = !STATE[key];
  saveData();
  updateCheckUI(key, STATE[key]);
  renderDecks(); 
}

function updateCheckUI(key, val) {
  const el = document.getElementById('btnToggle' + key.charAt(0).toUpperCase() + key.slice(1));
  if(!el) return;
  if(val) {
    el.classList.add('checked');
    el.querySelector('.status-icon').textContent = '‚úì';
  } else {
    el.classList.remove('checked');
    el.querySelector('.status-icon').textContent = '‚óã';
  }
}

function updateStats() {
  let known = 0, learning = 0;
  Object.entries(STATE.progress).forEach(([uid, p]) => {
    if(STATE.blacklist.has(uid)) return;
    if(p.score >= 4) known++;
    else if (p.score > 0) learning++;
  });
  
  let total = 0;
  const uniqueAll = new Set();
  STATE.activeDecks.forEach(d => {
      d.cards.forEach(c => {
         const uid = getCardId(d.id, c);
         if(!STATE.blacklist.has(uid)) uniqueAll.add(uid);
      });
  });
  total = uniqueAll.size;

  document.getElementById('statKnown').textContent = known;
  document.getElementById('statLearning').textContent = learning;
  document.getElementById('statTotal').textContent = total;
}

function getCardId(deckId, card) {
  return `${deckId}:${card.es.replace(/\s/g,'')}`;
}

function resetAllData() {
  if(confirm("Reset ALL data? Progress, custom cards, and settings will be lost.")) {
    localStorage.clear();
    location.reload();
  }
}

// --- BINDINGS ---
function bindEvents() {
  document.querySelectorAll('.nav-tab').forEach(btn => {
    btn.onclick = () => switchPanel(btn.dataset.panel);
  });
  
  document.querySelectorAll('.toggle-btn').forEach(btn => {
    btn.onclick = () => changeToggle(btn.dataset.group, btn.dataset.val);
  });
  
  document.getElementById('btnShowAnswer').onclick = () => showAnswer();
  document.getElementById('btnEasy').onclick = () => markCard(true);
  document.getElementById('btnHard').onclick = () => markCard(false);
  document.getElementById('btnNextCard').onclick = () => nextCard();
  document.getElementById('btnDeleteCard').onclick = deleteCurrentCard;
  
  document.getElementById('gameInput').onkeydown = (e) => {
    if(e.key === 'Enter') showAnswer();
  };
  
  document.getElementById('btnAddSubmit').onclick = onAddSubmit;
  document.getElementById('btnResetData').onclick = resetAllData;
}

// Start
init();

</script>
</body>
</html>
